<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yue&#39;s Jotter</title>
  
  
  <link href="https://stu-yue.github.io/atom.xml" rel="self"/>
  
  <link href="https://stu-yue.github.io/"/>
  <updated>2023-08-01T08:44:30.460Z</updated>
  <id>https://stu-yue.github.io/</id>
  
  <author>
    <name>stu-yue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hot Points</title>
    <link href="https://stu-yue.github.io/jottings/points/hot_points/"/>
    <id>https://stu-yue.github.io/jottings/points/hot_points/</id>
    <published>2023-07-22T12:00:53.000Z</published>
    <updated>2023-08-01T08:44:30.460Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Generate random numbers by reading <strong>thermal noise</strong> on CPU pins.</p></li><li><p><strong>Hot Plug</strong>, refers to the operation of inserting&#x2F;removing a device while it is running. In contrast, <strong>Cold Plug</strong> means do above operation while the device is powered off.</p></li><li><p>Software version’s explanation:</p><table><thead><tr><th>Version</th><th>Description</th></tr></thead><tbody><tr><td>Snapshot</td><td>Development version</td></tr><tr><td>Alpha</td><td>Internal beta</td></tr><tr><td>Beta</td><td>Public beta</td></tr><tr><td>Pre (M)</td><td>Similar to Alpha, sometimes subdivided into M_(Milestone) version</td></tr><tr><td>RC(Release Candidate)</td><td>During Beta stage, new features will continue to be added, but once the RC version is reached, there will mainly be on debugging and issue resolution.</td></tr><tr><td>GA(General Availability)</td><td>Some software may be labeled as “stable” or “production”.</td></tr><tr><td>Release&#x2F;Stable</td><td></td></tr><tr><td>Current</td><td>The latest version, but no necessarily a stable one.</td></tr><tr><td>Eval</td><td>There may be a monthly or fixed time limit for usage.</td></tr></tbody></table></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Generate random numbers by reading &lt;strong&gt;thermal noise&lt;/strong&gt; on CPU pins.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Hot Plug&lt;/strong&gt;, refer</summary>
      
    
    
    
    <category term="points" scheme="https://stu-yue.github.io/categories/points/"/>
    
    
    <category term="points" scheme="https://stu-yue.github.io/tags/points/"/>
    
  </entry>
  
  <entry>
    <title>Summa | The Majority of Memory Categories</title>
    <link href="https://stu-yue.github.io/jottings/architecture/summa_memory_categories/"/>
    <id>https://stu-yue.github.io/jottings/architecture/summa_memory_categories/</id>
    <published>2023-07-20T08:41:53.000Z</published>
    <updated>2023-07-22T11:56:11.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reproduced in <a href="https://embeddedinventor.com/8-types-of-memory-every-embedded-engineer-should-know-about/">8 types of memory every embedded engineer should know about!</a></p></blockquote><p>The majority of memory can be categorized as shown in the following picture:</p><img src="./summa_memory_categories/category.png" style="zoom:80%"><img src="./category.png" style="zoom:80%"><blockquote><p>The real difference between primary and secondary memories is the <strong>speed&#x2F;volatility(without power) tradeoffs</strong>.</p></blockquote><h3 id="Primary-Memory"><a href="#Primary-Memory" class="headerlink" title="Primary Memory"></a>Primary Memory</h3><p>Primary memory is <strong>very fast, but it cannot hold data without power</strong>. The popular name for Primary Memory is <strong>RAM</strong>, which has 2 most important types namely <strong>SRAM</strong> and <strong>DRAM</strong>.</p><blockquote><p>Bistable Circuit usually consists of <strong>two complementary transistors or other switching devices</strong>, <strong>one used to hold the circuit in one stable state and the other to switch the circuit to another stable state</strong>. The switch between these two states is triggered by the input signal. <strong>Bistable Circuit can store data. Latches and registers are bistable devices.</strong></p><img src="./summa_memory_categories/bistable.png" style="zoom:50%"><img src="./bistable.png" style="zoom:50%"></blockquote><ul><li><strong>SRAM is the use of bistable flip-flop to save information, as long as the power is not lost, the information is not lost.</strong></li><li><strong>DRAM uses capacitors to store charge to store information, so data stored in the DRAM must be constantly refreshed every few milliseconds or else it will end up being erased</strong>. The action is taken care of by a special device named <strong>DRAM controllers</strong>.</li></ul><img src="./summa_memory_categories/ram_arch.png" style="zoom:60%"><img src="./ram_arch.png" style="zoom:60%"><table><thead><tr><th></th><th>SRAM</th><th>DRAM</th></tr></thead><tbody><tr><td>Construction Principle</td><td>It uses a cross-coupled flip flop configuration of transistors</td><td>It uses a capacitor transistor circuit to hold data</td></tr><tr><td>Cost</td><td>Relatively more expensive, it needs more transistors per bit of data it can store</td><td>Relatively less expensive, as fewer transistors per bit of storage are needed</td></tr><tr><td>Speed</td><td>Faster</td><td>Slower (capacitor charge and discharge time)</td></tr><tr><td>Volatility</td><td>As long as power is ON, it can store data since it uses no capacitors</td><td>Data needs to be continuously refreshed (usually in the order of 4 times a second) since the capacitors leak power.</td></tr><tr><td>Power consumption</td><td>Less</td><td>More</td></tr><tr><td>Density</td><td>Less dense (6 transistors, more area needed)</td><td>Highly dense (1 pass transistor and 1 capacitor, easy to integrate)</td></tr><tr><td>Addition components needed</td><td>None</td><td>DRAM controllers are needed to make it work like an SRAM. This controller offloads the data refreshing duties of a microprocessor and hence a DRAM coupled with a DRAM controller behaves more like an SRAM from the processor’s perspective.</td></tr><tr><td>Application areas</td><td>Cache memory (Ls2)</td><td>Main memory (memory chips)</td></tr></tbody></table><blockquote><p>NVRAM or Non Volatile Random Access Memory, is a special type of RAM that can store data permanently. It’s basically an SRAM with a power supply</p></blockquote><h3 id="Secondary-Memory"><a href="#Secondary-Memory" class="headerlink" title="Secondary Memory"></a>Secondary Memory</h3><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><ul><li><p><strong>MASK ROM</strong>: The main characteristic of this device is the fact that the data is written onto the device as it gets manufactured and it is impossible to change them. This is done by designing the chip in such a manner so that it already contains the necessary data.</p><p>In order to mass production, the manufacturer makes a ROM or EPROM with original data as a sample in advance, and then mass-produces the same ROM as the sample. This kind of ROM sample for mass production is the MASK ROM, and the data burned in the MASK ROM can never be modified.</p></li><li><p><strong>PROM</strong> stands for Programmable Read-Only Memory. These are <strong>programmable chips for user needs</strong>, the main characteristic being it can <strong>only be programmed one time</strong>. That is it cannot be erased or reprogrammed. They are also known as <strong>One Time Programmable</strong> devices or <strong>OTP</strong>s for short. </p></li><li><p><strong>EPROM</strong> stands for Erasable Programmable Read-Only Memory. These chips usually <strong>have a small glass window on top and if you expose them to direct sunlight(UV, ultraviolet) that will erase the chip’s data.</strong> They can then be programmed again with fresh data.</p><ul><li>Cons: Inconvenient, instability, can not be exposed to the light source otherwise easy to lead to data loss</li></ul></li><li><p><strong>EEPROM</strong> stands for Electrically Erasable Programmable Read-Only Memory. These chips can be <strong>erased and reprogrammed using electricity</strong> as opposed to exposing them to UV rays as EPROMs. EEPROM can be erased and reprogrammed on a computer or dedicated device,  generally plugging and playing.</p></li></ul><h4 id="FLASH-MEMORY"><a href="#FLASH-MEMORY" class="headerlink" title="FLASH MEMORY"></a>FLASH MEMORY</h4><ol><li><p>The basic storage unit of flash memory is the transistor-based storage unit, and each storage unit can store 1 bit of data. Storage units are usually organized into a block, and each block contains thousands of storage units.</p></li><li><p>Each storage unit has a floating gate to store electric charges. The state of a storage unit can be determined as “1” or “0” based on the amount of electric charges stored in the floating gate. The state of a storage unit is changed by injecting or extracting electrons into&#x2F;from the floating gate to modify the amount of electric charges stored in it.</p></li><li><p>Flash memory uses <strong>Hot carrier injection(HCI)</strong> mechanism to write data. In simple terms, a certain storage unit is grounded at the <strong>source</strong>, a positive voltage is applied to its <strong>control gate</strong>, and a positive voltage is applied to the <strong>drain</strong> to generate a strong electric field between the source and drain. This will give electrons enough energy (<strong>hot carriers</strong>) to be attracted by the voltage at the <strong>control gate</strong> and injected into the <strong>floating gate</strong>. Afterwards, as the <strong>insulating material</strong> on the top and bottom of the <strong>floating gate</strong> is <strong>not conductive</strong>, these <strong>electrons are trapped in the floating gate and cannot escape</strong>. (Every time <strong>electrons enter and exit the surrounding silicon dioxide on the floating gate</strong>, <strong>it will cause aging</strong><a href="https://www.cnblogs.com/ricklz/p/16415763.html">[1]</a>)</p><img src="./summa_memory_categories/flash_particle.png" style="zoom:50%"><img src="./flash_particle.png" style="zoom:50%"></li><li><p>To save  cost, flash memory adopts page programming mode. Each page contains a certain number of storage units, and all units in a page are written at the same time.</p></li></ol><ul><li>Cons: Flash memory has the issue of wear-out (<strong>write&#x2F;erase endurance limits</strong>), which is usually mitigated by disabling bad blocks, and then reducing usable capacity.</li></ul><blockquote><ul><li><strong>USB flash disk, namely “U disk”</strong>, is a new generation of storage devices <strong>based on USB interface and flash memory chip as storage medium</strong>. It is basically composed of five parts: <strong>USB port, main control chip, flash memory chip, PCB backboard, outer package</strong>.</li><li><strong>USB flash drives, SD cards, and SSDs are a type of storage device that uses flash memory chips as the storage medium</strong>. They are primarily composed of a controller (main control) and flash memory chips, and have no mechanical structure, consisting purely of electronic circuitry. <strong>They are resistant to physical shocks and impacts.</strong> The controller manages data storage and other functions. Even after power loss, data remains stored in the memory cells.</li><li>USB flash drives generally have a cache on them to prevent the loss of data copies from being quickly plugged in&#x2F;out.</li></ul></blockquote><h4 id="OTHER"><a href="#OTHER" class="headerlink" title="OTHER"></a>OTHER</h4><ul><li>Hard Disk Drive: The disk reads data according to the polarity of the magnetic particle and writes data according to the polarity of the magnetic head.</li><li>Compact Disk: CD-ROM can only be read and not written to because after being burned once, each unit has a fixed different reflectivity (the reading probe emits laser and the reflected laser is read as “1”, or non-reflected laser is read as “0”).</li><li>Floppy Disk: A type of magnetic disk, less capacity, slower speed.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Reproduced in &lt;a href=&quot;https://embeddedinventor.com/8-types-of-memory-every-embedded-engineer-should-know-about/&quot;&gt;8 types of</summary>
      
    
    
    
    <category term="architecture" scheme="https://stu-yue.github.io/categories/architecture/"/>
    
    
    <category term="memory" scheme="https://stu-yue.github.io/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to Yue&#39;s Jotter</title>
    <link href="https://stu-yue.github.io/jottings/intro/"/>
    <id>https://stu-yue.github.io/jottings/intro/</id>
    <published>2023-07-13T08:23:57.000Z</published>
    <updated>2023-07-19T06:33:54.671Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Summa | Firmware and Drivers</title>
    <link href="https://stu-yue.github.io/jottings/architecture/summa_firmware_and_drivers/"/>
    <id>https://stu-yue.github.io/jottings/architecture/summa_firmware_and_drivers/</id>
    <published>2023-07-13T06:21:53.000Z</published>
    <updated>2023-07-20T05:15:59.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reproduced in <a href="https://embeddedinventor.com/firmware-vs-device-drivers-explained-with-examples/">Firmware vs Device Drivers: Explained with Examples!</a></p></blockquote><h3 id="Firmware-vs-Device-Drivers"><a href="#Firmware-vs-Device-Drivers" class="headerlink" title="Firmware vs. Device Drivers"></a>Firmware vs. Device Drivers</h3><table><thead><tr><th>Firmware</th><th>Device Drivers</th></tr></thead><tbody><tr><td>Firmware is a class of software that is written for specific custom hardware.</td><td>Device drivers are software that is needed to make a given hardware accessory</td></tr><tr><td>Firmware lives and runs directly on the hardware.</td><td>Device drivers live on hard-disk and run on the CPU.</td></tr><tr><td>Firmware is independent of an operating system, i.e.,  you can run any operating system on top of a  given motherboard’s firmware.</td><td>Device drivers are highly dependent on the operating system on which they are used. For example, for the same hardware device, you need different device drivers for using that on Windows vs Linux.</td></tr><tr><td>Firmware cannot be updated through an operating system, we need to go into the BIOS&#x2F;UEFI to update the device drivers.</td><td>Drivers can be updated from within the operating system.</td></tr><tr><td>Firmware engineers do not need any knowledge of operating systems. But they need core knowledge on processors and the latest RAMs, PCIe standards, and so on to write firmware that complies with the latest standards</td><td>Device driver engineers need knowledge about the specific device that they are using, the communication standard the device uses to talk to the computer (like Bluetooth, USB, etc), and the operating system the device driver is written for.</td></tr><tr><td>Firmware is written by motherboard manufacturers</td><td>Drivers are written by engineers in companies that produce hardware accessories that connect to your computer</td></tr><tr><td>Examples include the BIOS&#x2F;UEFI interface that comes with the computer’s motherboard</td><td>Examples include special software you install to handle the extra buttons on your mouse, software that comes with any non-standard hardware like special game controllers, also the software that helps us use all the standard hardware like USB storage devices, keyboards, mice, headphones, etc.</td></tr></tbody></table><p>Layers of software on a typical computer are shown in the following figure:</p><img src="./summa_firmware_and_drivers/layer.png" style="zoom:80%" ><img src="./layer.png" style="zoom:80%" ><blockquote><h4 id="Firmware"><a href="#Firmware" class="headerlink" title="Firmware"></a>Firmware</h4><p>​        <strong>Firmware is a computer program that is written to work directly on specific custom hardware and it lives in non-volatile memory such as a flash chip and it is executed directly from it. The job of the firmware is to make the hardware accessible to the operating system.</strong> Firmware can be thought of as the glasses through which the operating system can see the actual hardware!</p><p>​           Originally Firmware is written on Masked ROMs, which is a special type of memory that can be programmed&#x2F;written-data-to only once. The products were then shipped with these unchangeable programs called firmware and they run for ages till the device goes out of use.</p><p>​         The first replacement of Masked ROMs came in the form of EPROM which can be erased by exposure to UV light and then reprogrammed as required. Then came EEPROMs which used electricity to change the contents. Nowadays the Masked ROMs have been replaced with Flash memory, which is cheaper and serves the purpose. </p><h4 id="Device-Drivers"><a href="#Device-Drivers" class="headerlink" title="Device Drivers"></a>Device Drivers</h4><p><strong>Device drivers are programs that can control a given hardware and provide a software interface to it. Other programs like Operating Systems can interact with the hardware through this software interface without needing to know the actual underlying implementation of the software interface.</strong></p></blockquote><p>The relation graph between firmware and drivers is also shown below:</p><img src="./summa_firmware_and_drivers/relation_graph.png" style="zoom:80%" ><img src="./relation_graph.png" style="zoom:80%" ><p>​        Generally speaking, drivers and firmware together form the module that operates hardware. <strong>But why not make the firmware perfect so that it doesn’t require driver support?</strong> </p><p>​         The answer to the above question is, there are different operating systems which have completely different ways of operating hardware. So, <strong>on the one hand, hardware manufactures need to write firmware to make their hardware easier to use with software,</strong> but <strong>on the other hand, they cannot make the firmware too rigid in order to be compatible with various operating systems. They must leave enough room for software to freely operate</strong> —— and <strong>that’s where drivers come in.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Reproduced in &lt;a href=&quot;https://embeddedinventor.com/firmware-vs-device-drivers-explained-with-examples/&quot;&gt;Firmware vs Device </summary>
      
    
    
    
    <category term="architecture" scheme="https://stu-yue.github.io/categories/architecture/"/>
    
    
    <category term="firmware" scheme="https://stu-yue.github.io/tags/firmware/"/>
    
    <category term="driver" scheme="https://stu-yue.github.io/tags/driver/"/>
    
  </entry>
  
</feed>
