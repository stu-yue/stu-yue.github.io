<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yue&#39;s Jotter</title>
  
  
  <link href="https://stu-yue.github.io/atom.xml" rel="self"/>
  
  <link href="https://stu-yue.github.io/"/>
  <updated>2024-05-02T18:20:03.991Z</updated>
  <id>https://stu-yue.github.io/</id>
  
  <author>
    <name>stu-yue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://stu-yue.github.io/jottings/interview/memo_cpp_notes/"/>
    <id>https://stu-yue.github.io/jottings/interview/memo_cpp_notes/</id>
    <published>2024-05-03T03:48:39.342Z</published>
    <updated>2024-05-02T18:20:03.991Z</updated>
    
    
    
    
    <category term="interview" scheme="https://stu-yue.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stu-yue.github.io/jottings/interview/Hot100/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%92%8C/"/>
    <id>https://stu-yue.github.io/jottings/interview/Hot100/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%92%8C/</id>
    <published>2024-05-03T03:48:39.332Z</published>
    <updated>2024-05-01T11:32:46.191Z</updated>
    
    
    
    
    <category term="interview" scheme="https://stu-yue.github.io/categories/interview/"/>
    
    <category term="Hot100" scheme="https://stu-yue.github.io/categories/interview/Hot100/"/>
    
    
  </entry>
  
  <entry>
    <title>Memo | Law of Large Number</title>
    <link href="https://stu-yue.github.io/jottings/mathematics/memo_law_of_probability/"/>
    <id>https://stu-yue.github.io/jottings/mathematics/memo_law_of_probability/</id>
    <published>2023-10-21T05:56:53.000Z</published>
    <updated>2023-10-23T10:26:48.546Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Law-of-Large-Number"><a href="#1-Law-of-Large-Number" class="headerlink" title="1 Law of Large Number"></a>1 Law of Large Number</h4><h5 id="1-1-Folk-Understanding"><a href="#1-1-Folk-Understanding" class="headerlink" title="1.1 Folk Understanding"></a>1.1 Folk Understanding</h5><p>In simple terms, the large numbers theorem refers to that a random event may or may not occur  in a single experiment, but in a large number of repeated experiments, it often shows obvious regularity, that is, the frequency of the random event will converge to a constant value, which is the probability of the event.</p><p>Another way to express it is that when the sample data is infinite, the sample mean tends to population mean.</p><p>Because in real life, we can not run  an infinite number of experiments, and it is difficult to estimate the parameters of the population.</p><blockquote><p><strong>The law of large numbers connects mean values, which belong to mathematical statistics, with expectations, which belong to probability theory.</strong></p></blockquote><h5 id="1-2-Convergence-in-Probability"><a href="#1-2-Convergence-in-Probability" class="headerlink" title="1.2 Convergence in Probability"></a>1.2 Convergence in Probability</h5><ul><li>Weak Law: convergence in probability</li><li>Strong Law: almost sure convergence (outlier can be negligible in measure)</li></ul><h5 id="1-3-Bernoulli’s-Law"><a href="#1-3-Bernoulli’s-Law" class="headerlink" title="1.3 Bernoulli’s Law"></a>1.3 Bernoulli’s Law</h5><p>From the perspective of defining probability, <strong>reveals the relationship between probability and frequency</strong>.<br>$$<br>\lim\limits_{n\rightarrow \infin} P{ |\frac{f_A}{n} - p| &lt; \epsilon } &#x3D; 1<br>$$</p><h5 id="1-4-Khinchin’s-Law"><a href="#1-4-Khinchin’s-Law" class="headerlink" title="1.4 Khinchin’s Law"></a>1.4 Khinchin’s Law</h5><p>Priori Condition: Independent Identically Distributed,     $\lim\limits_{n\rightarrow \infin} P{ |\frac{1}{n}\sum\limits_{i&#x3D;1}^nX_i - \frac{1}{n}\sum\limits_{i&#x3D;1}^{n}E(X_i)| &lt; \epsilon } &#x3D; 1$</p><h5 id="1-5-Chebyshev’s-Law"><a href="#1-5-Chebyshev’s-Law" class="headerlink" title="1.5 Chebyshev’s Law"></a>1.5 Chebyshev’s Law</h5><p>Priori Condition: Independent Distributed,     $\lim\limits_{n\rightarrow \infin} P{ |\frac{1}{n}\sum\limits_{i&#x3D;1}^nX_i - \frac{1}{n}\sum\limits_{i&#x3D;1}^{n}\mu_i| &lt; \epsilon } &#x3D; 1$</p><h4 id="2-Heavy-tailed-Distribution"><a href="#2-Heavy-tailed-Distribution" class="headerlink" title="2 Heavy-tailed Distribution"></a>2 Heavy-tailed Distribution</h4><img src="./memo_law_of_probability/types.png" style="zoom:50%"><img src="./types.png" style="zoom:50%"><blockquote><p>Ref: <a href="https://www.jianshu.com/p/b7e06c4839b2">1</a>,  <a href="">2</a></p></blockquote><ul><li><p>Pareto  Distribution:<br>$$<br>P(X&gt;x) &#x3D; \left{<br>\begin{align}<br>(\frac{x_{min}}{x})^\alpha,&amp;\quad x\ge x_{min} \<br>1, &amp;\quad x&lt;x_{min}<br>\end{align}<br>\right.<br>$$</p><p>$$<br>f(x) &#x3D; \left{<br>\begin{align}<br>\frac{1}{x^\alpha}\cdot\frac{\alpha x_{min}^\alpha}{x},&amp;\quad x\ge x_{min} \<br>0, &amp;\quad x&lt;x_{min}<br>\end{align}<br>\right.<br>$$</p><p><strong>Pareto Principle</strong>: states that for many outcomes, roughly 80% of consequences com from 20% of causes (the “vital few”). Other names —— 80&#x2F;20 rule, the <strong>law of the vital few</strong> (states the imbalance phenomenon);</p><p><strong>Mathematically</strong>, the 80&#x2F;20 rule is roughly described by a <strong>power law distribution</strong> (also known as a Pareto distribution) for a particular set of parameters.</p><ul><li><p>Zipf Distribution:<br>$$<br>f(x) &#x3D; \frac{1}{x^\alpha\sum_{i&#x3D;1}^{n}(1&#x2F;i)^\alpha}, \  x &#x3D; 1,2,\cdots,n<br>$$<br><strong>Zipf’s law</strong> states that the value of the <em>n</em>th entry is <strong>inversely proportional</strong> to <em>n</em>, when a list of measured values is sorted in decreasing order.</p><ul><li>Zeta Distribution:  when $n\rightarrow \infty$,   $\text{Zipf}(\alpha, n)\rightarrow\text{Zeta}(\alpha)$ ; Zeta is regraded as a type of pareto distribution in the discrete distribution.<br>$$<br>f(x) &#x3D; \frac{1}{x^\alpha\sum_{i&#x3D;1}^{\infty}(1&#x2F;i)^\alpha}, \  x &#x3D; 1,2,\cdots,n,\text{and}\ \alpha &gt; 1<br>$$</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-Law-of-Large-Number&quot;&gt;&lt;a href=&quot;#1-Law-of-Large-Number&quot; class=&quot;headerlink&quot; title=&quot;1 Law of Large Number&quot;&gt;&lt;/a&gt;1 Law of Large Number&lt;/</summary>
      
    
    
    
    <category term="mathematics" scheme="https://stu-yue.github.io/categories/mathematics/"/>
    
    
    <category term="math" scheme="https://stu-yue.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Memo | CTC Introduction</title>
    <link href="https://stu-yue.github.io/jottings/statistics_ml/memo_ctc/"/>
    <id>https://stu-yue.github.io/jottings/statistics_ml/memo_ctc/</id>
    <published>2023-10-17T07:56:53.000Z</published>
    <updated>2023-10-17T15:49:36.026Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Problem-Description"><a href="#1-Problem-Description" class="headerlink" title="1 Problem Description"></a>1 Problem Description</h4><p>In seq2seq structure, given input sequence $X&#x3D;[x_1,\cdots,x_T]$ with corresponding label $Y &#x3D; [y_1,\cdots,y_N]$, such as speech recognition. Our job is to find a map, and this algorithm for classifying time series data is called <strong>Temporal Classification</strong>.</p><p>Compared with traditional classification, temporal classification has the following difficulties:</p><ol><li>The lengths of $X$ and $Y$ are variable.</li><li>The lengths of $X$ and $Y$ are not equal.</li><li>For an end-to-end model,  we don’t want manual design the alignment between $X$ and $Y$.</li></ol><p>The <strong>CTC</strong> provides the solution, that for a given input sequence $X$, CTC gives the output distribution of all possible $Y$. Based on this distribution, we can output the most likely outcome or give the probability of a certain output.</p><ul><li><p><strong>Loss Function</strong>: Given the input sequence $X$, we want to <strong>maximize the posterior probability</strong> $P(Y|X)$ of $Y$, and $P(Y|X)$ should be derivable so that we can perform the <strong>gradient-descent algorithm</strong>;</p></li><li><p><strong>Test</strong>: Given a trained model and input sequence $X$, we want to output $Y$ with the highest probability:<br>$$<br>Y^* &#x3D; \arg\max_YP(Y|X)<br>$$<br>Of course, when testing, we want Y to be searched as soon as possible (greedy, beam, prefix-beam, LM).</p></li></ul><h4 id="CTC-Procedure"><a href="#CTC-Procedure" class="headerlink" title="CTC Procedure"></a>CTC Procedure</h4><blockquote><p>REF: <a href="https://zhuanlan.zhihu.com/p/42719047">https://zhuanlan.zhihu.com/p/42719047</a></p></blockquote><h4 id="CTC-Traits"><a href="#CTC-Traits" class="headerlink" title="CTC Traits"></a>CTC Traits</h4><ol><li><p><strong>Conditional independence</strong>: A very unreasonable assumption of the CTC is its assumption that each time slice is independent of each other, which is a very bad assumption. </p><p>In OCR or speech recognition, there is some semantic information between each time slice, so the effect should be improved if the <strong>language model can be added</strong> to the CTC.</p></li><li><p><strong>Monotonic alignment</strong>: Another constraint of CTC is the monotonic alignment between input $X$ and output $Y$, which holds true in OCR and speech recognition. However, in some scenarios, such as machine translation, this constraint is not valid.</p></li><li><p><strong>Many-to-one mapping</strong>: Another constraint of CTC is that the length of the input sequence $X$ is greater than the length of the label data $Y$, but for scenarios where the length of $Y$ is greater than the length of $X$, <strong>CTC is invalid</strong>.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-Problem-Description&quot;&gt;&lt;a href=&quot;#1-Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;1 Problem Description&quot;&gt;&lt;/a&gt;1 Problem Description&lt;/</summary>
      
    
    
    
    <category term="statistics_ml" scheme="https://stu-yue.github.io/categories/statistics-ml/"/>
    
    
    <category term="ml" scheme="https://stu-yue.github.io/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>Memo | LM and Word Representation</title>
    <link href="https://stu-yue.github.io/jottings/statistics_ml/memo_lm_and_word_vector/"/>
    <id>https://stu-yue.github.io/jottings/statistics_ml/memo_lm_and_word_vector/</id>
    <published>2023-10-17T07:56:53.000Z</published>
    <updated>2023-10-22T10:59:24.709Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Language-Model"><a href="#Language-Model" class="headerlink" title="Language Model"></a>Language Model</h4><ul><li><p>语言模型是衡量一句话出现在自然语言中的概率的模型；</p></li><li><p>数学形式上，给定一句话 $s &#x3D; { w_1,\cdots,w_n }$，它对应的概率为：<br>$$<br>\begin{align*}<br>P(s) &amp;&#x3D; P(w_1,\cdots,w_n) \<br>&amp;&#x3D; P(w_1)\times P(w_2|w_1) \times \cdots \times P(w_n|w_1,\cdots,w_{n-1})\<br>&amp;&#x3D; \prod\limits_{i&#x3D;1}^{n}P(w_i|w_1,\cdots,w_{i-1})<br>\end{align*}<br>$$</p></li><li><p>语言模型的核心在于根据前文预测下一个词出现的概率；</p><p>$P(w_i|w_1,\cdots,w_{i-1}),\  w_i \in V,\ V&#x3D;{ w_1,\cdots,w_{|V|} }$</p></li><li><p>马尔可夫假设 (Markov Assumption)：当前词出现的概率只和它前面的k个词相关；<br>$$<br>\begin{align*}<br>P(w_i | w_1,\cdots,w_{i-1}) &amp;&#x3D; P(w_i | w_{i-k},\cdots,w_{i-1}) \<br>&amp; &#x3D; P(w_i) \qquad\qquad\qquad \rightarrow\quad\text{k&#x3D;0, Unigram Model} \<br>&amp; &#x3D; P(w_i | w_{i-1}) \qquad\qquad \rightarrow\quad\text{k&#x3D;1, Bigram Model} \<br>&amp; &#x3D; P(w_i | w_{i-2}, w_{i-1})\qquad\rightarrow\quad\text{k&#x3D;2, Trigram Model}\<br>\end{align*}<br>$$</p></li><li><p>用频率估计概率（大数定理——伯努利）<br>$$<br>\begin{align*}<br>P(w_i | w_1,\cdots,w_{i-1}) &amp;&#x3D; P(w_i | w_{i-k},\cdots,w_{i-1}) \<br>&amp; &#x3D; \frac{P(w_{i-k},\cdots,w_{i-1},w_i)}{P(w_{i-k},\cdots,w_{i-1})} \<br>&amp; \approx \frac{\text{count}(w_{i-k},\cdots,w_{i-1},w_i)}{\text{count}(w_{i-k},\cdots,w_{i-1})} \<br>\end{align*}<br>$$</p></li><li><p>Zipf Law, also known as the rank-size rule or Zipf distribution, is an empirical observation about the frequency distribution of words or other items in a given corpus of natural language. It states that <strong>the frequency of any word is inversely proportional to its rank in the frequency table</strong>.</p><ul><li><p>隐藏信息，排位靠后的词的频率非常低，甚至未出现在语料中；</p></li><li><p>数据稀疏，对于未出现在语料中的词或n-gram，无法估计其概率；</p><ul><li>平滑技术 （拉普拉斯平滑、古德-图灵平滑、插值平滑、Katz平滑）</li></ul><p>$$<br>\begin{align*}<br>P(w_i | w_1,\cdots,w_{i-1}) &amp;&#x3D; P(w_i | w_{i-k},\cdots,w_{i-1}) \<br>&amp; &#x3D; \frac{P(w_{i-k},\cdots,w_{i-1},w_i)}{P(w_{i-k},\cdots,w_{i-1})} \<br>&amp; \approx \frac{\text{count}(w_{i-k},\cdots,w_{i-1},w_i)+1}{\text{count}(w_{i-k},\cdots,w_{i-1})+|V|} \<br>\end{align*}<br>$$</p><ul><li><p>回退策略<br>$$<br>\begin{align*}<br>P(w_i | w_1,\cdots,w_{i-1}) &amp;&#x3D; P(w_i | w_{i-k},\cdots,w_{i-1}) \<br>&amp; &#x3D; \frac{P(w_{i-k},\cdots,w_{i-1},w_i)}{P(w_{i-k},\cdots,w_{i-1})} \<br>&amp; \approx \frac{\text{count}(w_{i-k},\cdots,w_{i-1},w_i)}{\text{count}(w_{i-k},\cdots,w_{i-1})}\qquad \rightarrow\quad\text{students opened their} \<br>&amp; \approx \frac{\text{count}(w_{i-k+j},\cdots,w_{i-1},w_i)}{\text{count}(w_{i-k+j},\cdots,w_{i-1})}\quad \rightarrow\quad\text{opened their} \<br>\end{align*}<br>$$</p></li><li><p>参数规模问题：随着k的增大，参数数目呈指数增长，无法存储；</p><p>k&#x3D;1，参数量&#x3D;$|V|^2$；k&#x3D;2，参数量&#x3D;$|V|^3$；k&#x3D;n-1，参数量&#x3D;$|V|^n$；</p></li></ul></li></ul></li><li><p>困惑度（Perplexity）</p><ul><li><p>用来衡量一个概率分布或概率模型预测样本的好坏程度；</p></li><li><p>可以用来比较两个概率模型，低困惑度的概率模型能更好地预测样本；<br>$$<br>\text{Perplexity}(s) &#x3D; 2^{H(s)} &#x3D; \sqrt[n]{1&#x2F;P(w_1,\cdots,w_n)}<br>$$</p></li></ul></li></ul><h4 id="Word-Representation"><a href="#Word-Representation" class="headerlink" title="Word Representation"></a>Word Representation</h4><ul><li><p>词库：</p><ul><li>WordNet：一个包含同义词（ synonym ）和上位词（ hypernyms ）的知识库；</li><li>词库的问题：<ul><li>缺少差异性 (proficient也被视为good的同义词)，不够精确；</li><li>缺少新词，无法及时更新</li><li>主观性，人工标注；</li></ul></li></ul></li><li><p>离散词表示：</p><ul><li><p>One-hot表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单词表示motel = [0 0 0 0 0 1 0]</span><br><span class="line">   hotel = [0 0 0 1 0 0 0]</span><br><span class="line">文本表示The students opened their books</span><br><span class="line">   [0 0 1 1 0 0 1 0]</span><br><span class="line">        ⬆</span><br><span class="line">   次数、频率、逆文档频率、TF-IDF、...</span><br></pre></td></tr></table></figure></li><li><p>词袋模型（Bag of Word）：词袋模型用于文本表示，如果每个词为One-hot表示，那么把每个词的One-hot向量相加，得到的向量就是该文本基于BOW得到的表示；</p></li><li><p>词频（Term Frequency，TF）：在文档中出现频率越高的词对当前文档可能越重要；<br>$$<br>f_{ij} &#x3D; \frac{\text{count}(\text{term}\ i)\text{in doc} \ j}{\text{count}(\text{all term})\text{in doc} \ j}, \<br>tf_{ij} &#x3D; \frac{f_{ij}}{\max_k(f_{kj})}<br>$$</p></li><li><p>逆文档频率（Inverse Document Frequency，IDF）：在很多文档中都出现的词可能不重要（如虚词）；<br>$$<br>df_i &#x3D; \text{doc frequency of term}\ i &#x3D; \text{numbers of doc containing term} \ i, \<br>idf_i &#x3D; \log_2\frac{N}{df_i} \ \text{（N为文档总数）}<br>$$</p></li><li><p>TF-IDF：综合一个词在当前文档中的频率和所有文档中出现的次数来度量这个词对当前文档重要性；<br>$$<br>tf_{ij}-idf_i &#x3D; tf_{ij}*idf_i &#x3D; tf_{ij}*\log_2\frac{N}{df_i}<br>$$</p></li><li><p>N-gram：N元组提取局部的上下文你信息；</p></li><li><p>离散词表示问题：语义鸿沟、维度爆炸；</p></li></ul></li><li><p>分布式词表示（词嵌入）</p><ul><li><p>用一个低维稠密的向量表示单词的整体含义；</p></li><li><p>核心思想：一个词的含义能被该词所在的上下文反映；</p></li><li><p>Co-occurrence：</p><ul><li>基于窗口的共现矩阵：<ul><li>统计窗口内单词之间的共现信息；</li><li>类似于word2vec；</li><li>能够捕获一些句法和语义信息（局部信息）；</li></ul></li><li>基于文档的共现矩阵：<ul><li>统计文档和单词之间的共现信息；</li><li>Latent Semantics Analysis (LSA)；</li><li>能够捕获话题信息（全局信息）；</li></ul></li></ul></li><li><p>Word2vec[Mikolov et al. 2013] 是一套学习词向量的算法框架</p><ul><li>算法思想：大量的自然语言文本（训练语料）</li><li>为词表中的每个词随机初始化一个向量表示</li><li>遍历文本中的每个单词 $c$，其上下文单词为 $o$</li><li>使用单词 $c$ 的上下文 $o$ 预测单词 $c$ 的概率分布（核心思想）</li><li>更新词向量的表示使得单词 $c$ 的预测概率最大化</li><li>连续词袋模型（CBOW，Continuous Bag of Words）</li><li>目标：通过局部语言模型的优化，获得词向量</li><li>优化目标：固定上下文词向量表示，计算中心词的似然函数，最大化其似然（负对数）</li><li>计算优化：负采样（Negative Sampling）<ul><li>为避免softmax计算整个庞大的词表，通常采用负采样的方法，将多分类问题转换为二分类问题；大大减少了训练时间和计算成本；</li></ul></li><li>Skip-gram：中心词 $c$ 预测上下文 $o$；</li></ul><table><thead><tr><th></th><th>优点</th><th>缺点</th><th>代表方法</th></tr></thead><tbody><tr><td>共现矩阵法</td><td>速度快，有效利用统计数据</td><td>过分依赖单词共现性和数据量</td><td>LSA, HAL</td></tr><tr><td>直接学习法</td><td>能够捕获语法和语义信息</td><td>速度和数据规模相关，未有效利用统计数据</td><td>Skip-gram,  CBOW</td></tr></tbody></table><p>基于计数的和基于预测的都探究了语料库的潜在共现统计</p></li><li><p>GloVe：集两家之长</p><ul><li><p>共现概率矩阵$X_{ij}$；</p></li><li><p>单词 $w_i$，$w_j$ 的词向量 $v_i$，$v_j$；</p></li><li><p>以学习的方式，用词向量之间的语义关系来拟合共现概率矩阵；<br>$$<br>J &#x3D; \sum\limits_{i,j&#x3D;1}^{|V|}f(X_{ij})(v_i^Tv_j+b_i+b_j-\log X_{ij})^2 \<br>v_i^Tv_j \quad\rightarrow\quad\text{局部信息} \<br>\log X_{ij}\quad\rightarrow\quad\text{全局统计信息} \<br>$$</p></li><li><p>训练快，适应于大规模数据，在小规模数据上性能优秀；</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Language-Model&quot;&gt;&lt;a href=&quot;#Language-Model&quot; class=&quot;headerlink&quot; title=&quot;Language Model&quot;&gt;&lt;/a&gt;Language Model&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;语言模型是衡量一句话出现在</summary>
      
    
    
    
    <category term="statistics_ml" scheme="https://stu-yue.github.io/categories/statistics-ml/"/>
    
    
    <category term="ml" scheme="https://stu-yue.github.io/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>Memo | ISA and Micro-architecture</title>
    <link href="https://stu-yue.github.io/jottings/architecture/memo_isa_and_micro_architecture/"/>
    <id>https://stu-yue.github.io/jottings/architecture/memo_isa_and_micro_architecture/</id>
    <published>2023-10-14T10:21:53.000Z</published>
    <updated>2023-10-15T06:29:11.484Z</updated>
    
    <content type="html"><![CDATA[<h4 id="What-is-CPU"><a href="#What-is-CPU" class="headerlink" title="What is CPU?"></a>What is CPU?</h4><ol><li><p>CPUs are a general purpose, flexible architecture that take in a stream of instructions from all types of workloads, and compute or process information based on those instructions.</p><p>Simply put, CPUs do what we tell them or program them to do.</p></li><li><p>This ability to continue shrinking transistors is based on a famous law&#x2F;observation that we in the industry refer to as Moore’s Law, that is, we can double the number of transistors per unit area about every two year.</p></li><li><p><strong>Bug Aside</strong>: Operators traced an error on the computers to a moth trapped in a relay, recoining the term “bug”.</p></li><li><p><strong>CPU Architecture</strong>: </p></li><li><p>**ENIAC: ** In early period, computer <strong>programs are hardware-based</strong>. Computers with <strong>data in memory and programs embedded in the hardware</strong> are computationally inefficient and less flexible.</p></li><li><p><strong>Von Neumann Machine</strong>: Programs are encoded as data and stored in memory (Principle of Stored Program Control).</p><img src="./memo_isa_and_micro_architecture/von_neumann.png" style="zoom:30%"><img src="./von_neumann.png" style="zoom:30%"></li><li><p><strong>Harvard Machine</strong>: A memory structure that separates program instruction storage from data storage. <strong>CPU can access instructions and read&#x2F;write data at the same time</strong>.</p><ol><li>Use two independent memory modules to store instructions and data respectively, and each storage module does not allow instructions and data to coexist;</li><li>Use two independent buses as a dedicated communication path between the CPU and each memory, and these two buses are unrelated.</li></ol><img src="./memo_isa_and_micro_architecture/harvard.png" style="zoom:40%"><img src="./harvard.png" style="zoom:40%"></li></ol><blockquote><p>In fact, the vast majority of modern computers use “Modified Harvard Architecture,” where instructions and data share the same address space, but the cache is separate.</p><p>As it stands, von Neumann for large-scale processing, and Harvard for small-scale processing.</p></blockquote><ol start="5"><li><p>CPU workflow architecture:</p><img src="./memo_isa_and_micro_architecture/arch.png" style="zoom:50%"><img src="./arch.png" style="zoom:30%"></li></ol><h4 id="Instruction-Set-Architecture"><a href="#Instruction-Set-Architecture" class="headerlink" title="Instruction Set Architecture"></a>Instruction Set Architecture</h4><p>The ISA is the dictionary of instructions, data types, and the formats that the CPU adhering to that ISA must execute. The <strong>ISA</strong> is used as a design spec (<strong>specification</strong>) that tells the engineer what operations it needs to execute. Because of this layer of abstraction, the <strong>instructions</strong> in the ISA are <strong>implementation independent</strong>. <strong>Micro-architecture is the concrete implementation of ISA in the hardware</strong>.</p><img src="./memo_isa_and_micro_architecture/isa.png" style="zoom:50%"><img src="./isa.png" style="zoom:50%"><p><strong>CISC (Complex Instruction Set Computers)</strong>: </p><ul><li>Early CPUs all used CISC, which was designed to perform the required computational tasks <strong>with minimal</strong> machine language <strong>instructions</strong>.</li><li>In order to achieve complex operations, <strong>microprocessors</strong> provide programmers with functions similar to various registers and machine instructions, but also through <strong>microprograms</strong> stored in read-only memory (<strong>ROM</strong>) to achieve its <strong>extremely powerful functions</strong>.</li></ul><p><strong>RISC (Reduced Instruction Set Computers)</strong>: </p><ul><li>In CISC, many complex instructions require extremely complex operations, and most of these instructions are direct copies of some high-level language, so the universality is poor. Because of the secondary microcode execution, it also slows down the operation of simple instruction systems that are frequently invoked.</li></ul><blockquote><p><strong>Summary:</strong> </p><p>The <strong>complex</strong> instructions are converted into a <strong>microprogram</strong>, which is stored in the <strong>microservice</strong> memory when the CPU is manufactured. A microprogram contains several <strong>microinstructions</strong> (also known as <strong>microcode</strong>), and when <strong>executing complex instructions</strong>, it is actually <strong>executing a microprogram</strong>. </p><p>This also brings a difference between the two instruction sets, <strong>the execution of microprograms cannot be interrupted,</strong> while <strong>RISC instructions can be interrupted between each other</strong>, so in theory <strong>RISC can respond faster to interrupts</strong>.</p><ul><li><p>Command  Capability:</p><ul><li>The instruction capability of CISC is strong, but the usage rate of most instructions is low, which increases the complexity of CPU. Instructions are <strong>variable length format</strong>, which must be divided into different length instructions, so more processing work is needed when executing a single instruction.</li><li>Most RISC instructions are single-cycle instructions, <strong>the length of instructions is fixed</strong>, and the CPU is fast and stable when executing instructions.</li></ul></li><li><p>Addressing Mode:</p><ul><li>CISC supports a variety of addressing methods. RISC supports few addressing methods.</li></ul></li><li><p>Implementation Mode:</p><ul><li>CISC is implemented through microprogrammed control technology (microcode).</li><li>RISC adds a general register, hard-wired logic control is the main, suitable for pipelined execution. RISC can optimize compilation and effectively support high-level languages.</li></ul></li><li><p>R&amp;D Cycle:</p><ul><li>CISC has a long development cycle.</li><li>RISC hardware is simple, so its manufacturing process is simple and low cost.</li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;What-is-CPU&quot;&gt;&lt;a href=&quot;#What-is-CPU&quot; class=&quot;headerlink&quot; title=&quot;What is CPU?&quot;&gt;&lt;/a&gt;What is CPU?&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CPUs are a general purp</summary>
      
    
    
    
    <category term="architecture" scheme="https://stu-yue.github.io/categories/architecture/"/>
    
    
    <category term="instruction set arch" scheme="https://stu-yue.github.io/tags/instruction-set-arch/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Installation</title>
    <link href="https://stu-yue.github.io/jottings/tools/docker/memo_install/"/>
    <id>https://stu-yue.github.io/jottings/tools/docker/memo_install/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-04-21T13:44:05.127Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/">安装指南</a>，这里主要介绍 Docker 在 <code>Linux</code> 、<code>Windows 10</code> 和 <code>macOS</code> 上的安装。</p><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><blockquote><p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>Docker 支持以下版本的 <a href="https://ubuntu.com/server">Ubuntu</a> 操作系统：</p><ul><li>Ubuntu Hirsute 21.04</li><li>Ubuntu Groovy 20.10</li><li>Ubuntu Focal 20.04 (LTS)</li><li>Ubuntu Bionic 18.04 (LTS)</li></ul><p>Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。</p><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><h2 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h2><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install apt-transport-https \</span><br><span class="line">ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure><p>然后，我们需要向 <code>sources.list</code> 中添加 Docker 软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p></blockquote><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h2 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><blockquote><p>若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -fsSL test.docker.com -o get-docker.sh</span></span><br><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="comment"># sudo sh get-docker.sh --mirror AzureChinaCloud</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b8dfde127a29: Pull complete</span><br><span class="line">Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <a href="https://yeasy.gitbook.io/docker_practice/install/mirror">国内镜像加速</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker 分为 &lt;code&gt;stable&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;nightly&lt;/code&gt; 三个更新频道。&lt;/p&gt;
&lt;p&gt;官方网站上有各种环境下的 &lt;a href=&quot;https://docs.docker.com/get-d</summary>
      
    
    
    
    <category term="tools" scheme="https://stu-yue.github.io/categories/tools/"/>
    
    <category term="docker" scheme="https://stu-yue.github.io/categories/tools/docker/"/>
    
    
    <category term="docker" scheme="https://stu-yue.github.io/tags/docker/"/>
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Network</title>
    <link href="https://stu-yue.github.io/jottings/tools/docker/memo_network/"/>
    <id>https://stu-yue.github.io/jottings/tools/docker/memo_network/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-04-29T08:30:07.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-外部访问容器"><a href="#1-外部访问容器" class="headerlink" title="1 外部访问容器"></a>1 外部访问容器</h1><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P nginx:alpine</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span> -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        <span class="string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs fa</span><br><span class="line">172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h2 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h2><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><h2 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h2><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure><h2 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h2><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure><h2 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h2><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure><h1 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2 容器互联"></a>2 容器互联</h1><p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p><h2 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h2><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href="https://yeasy.gitbook.io/docker_practice/swarm_mode">Swarm mode</a>，在本小节中你可以忽略它。</p><h2 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h2><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>再打开一个新的终端查看容器信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             <span class="string">&quot;sh&quot;</span>                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             <span class="string">&quot;sh&quot;</span>                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: <span class="built_in">seq</span>=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: <span class="built_in">seq</span>=1 ttl=64 time=0.118 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox1</span></span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.2: <span class="built_in">seq</span>=0 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: <span class="built_in">seq</span>=1 ttl=64 time=0.143 ms</span><br></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h1 id="3-配置-DNS"><a href="#3-配置-DNS" class="headerlink" title="3 配置 DNS"></a>3 配置 DNS</h1><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p><p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...</span><br><span class="line">tmpfs on /etc/resolv.conf type tmpfs ...</span><br></pre></td></tr></table></figure><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm ubuntu:18.04  cat etc/resolv.conf</span><br><span class="line"></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-外部访问容器&quot;&gt;&lt;a href=&quot;#1-外部访问容器&quot; class=&quot;headerlink&quot; title=&quot;1 外部访问容器&quot;&gt;&lt;/a&gt;1 外部访问容器&lt;/h1&gt;&lt;p&gt;容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 &lt;code&gt;-P&lt;/cod</summary>
      
    
    
    
    <category term="tools" scheme="https://stu-yue.github.io/categories/tools/"/>
    
    <category term="docker" scheme="https://stu-yue.github.io/categories/tools/docker/"/>
    
    
    <category term="docker" scheme="https://stu-yue.github.io/tags/docker/"/>
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Operation</title>
    <link href="https://stu-yue.github.io/jottings/tools/docker/memo_operation/"/>
    <id>https://stu-yue.github.io/jottings/tools/docker/memo_operation/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-04-26T13:37:16.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-启动"><a href="#1-启动" class="headerlink" title="1  启动"></a>1  启动</h1><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h2 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h2><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/echo <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/#</span><br></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/# pwd</span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href="https://yeasy.gitbook.io/docker_practice/repository">registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h2 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h2><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:/# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   11 ?        00:00:00 ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h1 id="2-守护态运行"><a href="#2-守护态运行" class="headerlink" title="2 守护态运行"></a>2 守护态运行</h1><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 **<code>-d</code> 参数 (Detach)**来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h1 id="3-终止"><a href="#3-终止" class="headerlink" title="3 终止"></a>3 终止</h1><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h1 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4  进入容器"></a>4  进入容器</h1><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h2 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h2><p>下面示例如何使用 <code>docker attach</code> 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">$ docker attach 243c</span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h2 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h2><h3 id="i-t-参数"><a href="#i-t-参数" class="headerlink" title="-i -t 参数"></a><code>-i</code> <code>-t</code> 参数</h3><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker exec -i 69d1 bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker exec -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/#</span><br></pre></td></tr></table></figure><p><strong>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</strong></p><h1 id="4-导出和导入"><a href="#4-导出和导入" class="headerlink" title="4 导出和导入"></a>4 导出和导入</h1><h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        <span class="string">&quot;/bin/bash&quot;</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h2 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h2><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</strong></p></blockquote><h2 id="保存镜像归档文件"><a href="#保存镜像归档文件" class="headerlink" title="保存镜像归档文件"></a>保存镜像归档文件</h2><ul><li><p><strong>将一个镜像保存到一个 tar 文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o myimage_v1.tar myimage:v1</span><br></pre></td></tr></table></figure></li><li><p><strong>将多个镜像保存到一个 tar 文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o myimages.tar myimage:v1 myimage:v2</span><br></pre></td></tr></table></figure></li><li><p><strong>通过重定向来保存镜像</strong> （不用<code>-o</code>参数）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save myimage:v1 &gt; myimage_v1.tar</span><br></pre></td></tr></table></figure></li></ul><h2 id="加载镜像归档文件"><a href="#加载镜像归档文件" class="headerlink" title="加载镜像归档文件"></a>加载镜像归档文件</h2><ul><li><p><strong>使用 <code>--input</code> 选项</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load --input[-i] myimage.tar</span><br></pre></td></tr></table></figure></li><li><p><strong>使用管道</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> myimage.tar | docker load [-]</span><br></pre></td></tr></table></figure><blockquote><p>其中 - 代表标准输入&#x2F;输出。</p></blockquote></li></ul><h1 id="5-删除"><a href="#5-删除" class="headerlink" title="5 删除"></a>5 删除</h1><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">rm</span> trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h2><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-启动&quot;&gt;&lt;a href=&quot;#1-启动&quot; class=&quot;headerlink&quot; title=&quot;1  启动&quot;&gt;&lt;/a&gt;1  启动&lt;/h1&gt;&lt;p&gt;启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（&lt;code&gt;exited&lt;/code&gt;）的</summary>
      
    
    
    
    <category term="tools" scheme="https://stu-yue.github.io/categories/tools/"/>
    
    <category term="docker" scheme="https://stu-yue.github.io/categories/tools/docker/"/>
    
    
    <category term="docker" scheme="https://stu-yue.github.io/tags/docker/"/>
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Regitstry and Data</title>
    <link href="https://stu-yue.github.io/jottings/tools/docker/memo_registry_and_data/"/>
    <id>https://stu-yue.github.io/jottings/tools/docker/memo_registry_and_data/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-04-26T15:28:16.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-私有仓库"><a href="#1-私有仓库" class="headerlink" title="1 私有仓库"></a>1 私有仓库</h1><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p><h2 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h2><h3 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h3><p>你可以使用官方 <code>registry</code> 镜像来运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><h2 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h2><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;ubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><h2 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h2><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><h3 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h3><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot;: [</span><br><span class="line">    &quot;192.168.199.100:5000&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p><h1 id="2-数据卷"><a href="#2-数据卷" class="headerlink" title="2 数据卷"></a>2 数据卷</h1><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UnionFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h2 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><p>复制</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h2><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:/usr/share/nginx/html \</span><br><span class="line">    --mount source=my-vol,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure><h2 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h2><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h2 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume <span class="built_in">rm</span> my-vol</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure><h1 id="3-挂载主机目录"><a href="#3-挂载主机目录" class="headerlink" title="3 挂载主机目录"></a>3 挂载主机目录</h1><h2 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h2><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，<strong>以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错</strong>。</p><p>**Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>**。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html:ro \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="built_in">readonly</span> \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/nginx/html <span class="comment"># touch new.txt</span></span><br><span class="line"><span class="built_in">touch</span>: new.txt: Read-only file system</span><br></pre></td></tr></table></figure><h2 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h2><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/src/webapp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/usr/share/nginx/html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h2 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h2><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span><br><span class="line">1  <span class="built_in">ls</span></span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-私有仓库&quot;&gt;&lt;a href=&quot;#1-私有仓库&quot; class=&quot;headerlink&quot; title=&quot;1 私有仓库&quot;&gt;&lt;/a&gt;1 私有仓库&lt;/h1&gt;&lt;p&gt;有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="tools" scheme="https://stu-yue.github.io/categories/tools/"/>
    
    <category term="docker" scheme="https://stu-yue.github.io/categories/tools/docker/"/>
    
    
    <category term="docker" scheme="https://stu-yue.github.io/tags/docker/"/>
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Usage</title>
    <link href="https://stu-yue.github.io/jottings/tools/docker/memo_usage/"/>
    <id>https://stu-yue.github.io/jottings/tools/docker/memo_usage/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-04-26T12:35:07.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Docker命令简介"><a href="#0-Docker命令简介" class="headerlink" title="0 Docker命令简介"></a>0 Docker命令简介</h1><img src="./memo_usage/docker.png" style="zoom:100%"><img src="./docker.png" style="zoom:80%"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime <span class="keyword">for</span> containers</span><br><span class="line"></span><br><span class="line">Common Commands:</span><br><span class="line">  run         Create and run a new container from an image</span><br><span class="line">  <span class="built_in">exec</span>        Execute a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line">  ps          List containers</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  pull        Download an image from a registry</span><br><span class="line">  push        Upload an image to a registry</span><br><span class="line">  images      List images</span><br><span class="line">  login       Log <span class="keyword">in</span> to a registry</span><br><span class="line">  <span class="built_in">logout</span>      Log out from a registry</span><br><span class="line">  search      Search Docker Hub <span class="keyword">for</span> images</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  info        Display system-wide information</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  buildx*     Docker Buildx</span><br><span class="line">  checkpoint  Manage checkpoints</span><br><span class="line">  compose*    Docker Compose</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  image       Manage images</span><br><span class="line">  manifest    Manage Docker image manifests and manifest lists</span><br><span class="line">  network     Manage networks</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Swarm Commands:</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach <span class="built_in">local</span> standard input, output, and error streams to a running container</span><br><span class="line">  commit      Create a new image from a container<span class="string">&#x27;s changes</span></span><br><span class="line"><span class="string">  cp          Copy files/folders between a container and the local filesystem</span></span><br><span class="line"><span class="string">  create      Create a new container</span></span><br><span class="line"><span class="string">  diff        Inspect changes to files or directories on a container&#x27;</span>s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  <span class="built_in">export</span>      Export a container<span class="string">&#x27;s filesystem as a tar archive</span></span><br><span class="line"><span class="string">  history     Show the history of an image</span></span><br><span class="line"><span class="string">  import      Import the contents from a tarball to create a filesystem image</span></span><br><span class="line"><span class="string">  inspect     Return low-level information on Docker objects</span></span><br><span class="line"><span class="string">  kill        Kill one or more running containers</span></span><br><span class="line"><span class="string">  load        Load an image from a tar archive or STDIN</span></span><br><span class="line"><span class="string">  logs        Fetch the logs of a container</span></span><br><span class="line"><span class="string">  pause       Pause all processes within one or more containers</span></span><br><span class="line"><span class="string">  port        List port mappings or a specific mapping for the container</span></span><br><span class="line"><span class="string">  rename      Rename a container</span></span><br><span class="line"><span class="string">  restart     Restart one or more containers</span></span><br><span class="line"><span class="string">  rm          Remove one or more containers</span></span><br><span class="line"><span class="string">  rmi         Remove one or more images</span></span><br><span class="line"><span class="string">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span></span><br><span class="line"><span class="string">  start       Start one or more stopped containers</span></span><br><span class="line"><span class="string">  stats       Display a live stream of container(s) resource usage statistics</span></span><br><span class="line"><span class="string">  stop        Stop one or more running containers</span></span><br><span class="line"><span class="string">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span></span><br><span class="line"><span class="string">  top         Display the running processes of a container</span></span><br><span class="line"><span class="string">  unpause     Unpause all processes within one or more containers</span></span><br><span class="line"><span class="string">  update      Update configuration of one or more containers</span></span><br><span class="line"><span class="string">  wait        Block until one or more containers stop, then print their exit codes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Global Options:</span></span><br><span class="line"><span class="string">      --config string      Location of client config files (default &quot;/home/wangy/.docker&quot;)</span></span><br><span class="line"><span class="string">  -c, --context string     Name of the context to use to connect to the daemon</span></span><br><span class="line"><span class="string">                           (overrides DOCKER_HOST env var and default context set with</span></span><br><span class="line"><span class="string">                           &quot;docker context use&quot;)</span></span><br><span class="line"><span class="string">  -D, --debug              Enable debug mode</span></span><br><span class="line"><span class="string">  -H, --host list          Daemon socket to connect to</span></span><br><span class="line"><span class="string">  -l, --log-level string   Set the logging level (&quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;,</span></span><br><span class="line"><span class="string">                           &quot;fatal&quot;) (default &quot;info&quot;)</span></span><br><span class="line"><span class="string">      --tls                Use TLS; implied by --tlsverify</span></span><br><span class="line"><span class="string">      --tlscacert string   Trust certs signed only by this CA (default</span></span><br><span class="line"><span class="string">                           &quot;/home/wangy/.docker/ca.pem&quot;)</span></span><br><span class="line"><span class="string">      --tlscert string     Path to TLS certificate file (default</span></span><br><span class="line"><span class="string">                           &quot;/home/wangy/.docker/cert.pem&quot;)</span></span><br><span class="line"><span class="string">      --tlskey string      Path to TLS key file (default &quot;/home/wangy/.docker/key.pem&quot;)</span></span><br><span class="line"><span class="string">      --tlsverify          Use TLS and verify the remote</span></span><br><span class="line"><span class="string">  -v, --version            Print version information and quit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run &#x27;</span>docker COMMAND --<span class="built_in">help</span><span class="string">&#x27; for more information on a command.</span></span><br></pre></td></tr></table></figure><h1 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1 获取镜像"></a>1 获取镜像</h1><p>之前提到过，<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">92dc2a97ff99: Pull complete</span><br><span class="line">be13a9d27eb8: Pull complete</span><br><span class="line">c8299583700a: Pull complete</span><br><span class="line">Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">docker.io/library/ubuntu:18.04</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> **命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>**。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照</em> <a href="https://yeasy.gitbook.io/docker_practice/install/mirror"><em>镜像加速器</em></a> <em>一节配置加速器。</em></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><p>复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 18.04.1 LTS&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;18.04&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbook.io/docker_practice/container">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h1 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2  列出镜像"></a>2  列出镜像</h1><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu               bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h2 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h2><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>63.3MB</code>，但是在 <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/bionic/images/sha256-32776cc92b5810ce72e77aca1d949de1f348e1d281d3f00ebcc22a3adcdc9f42?context=explore">Docker Hub</a> 显示的却是 <code>25.47 MB</code>。这是因为 <strong>Docker Hub 中显示的体积是压缩后的体积</strong>。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，**<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗**。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker system <span class="built_in">df</span></span><br><span class="line"></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              24                  0                   1.992GB             1.992GB (100%)</span><br><span class="line">Containers          1                   0                   62.82MB             62.82MB (100%)</span><br><span class="line">Local Volumes       9                   0                   652.2MB             652.2MB (100%)</span><br><span class="line">Build Cache                                                 0B                  0B</span><br></pre></td></tr></table></figure><h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，**<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像**。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></table></figure><h2 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h2><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><p>复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h2 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h2><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><ul><li><p>根据仓库名列出镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu              bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure></li><li><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure></li><li><p>除此以外，**<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>**。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p></li><li><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f label=com.example.version=0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h2><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -q</span><br><span class="line">5f515359c7f8</span><br><span class="line">05a60462f8ba</span><br><span class="line">fe9198c04d62</span><br><span class="line">00285df0df87</span><br><span class="line">329ed837d508</span><br><span class="line">329ed837d508</span><br></pre></td></tr></table></figure><p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/introduction/">Go 的模板语法</a>。</p><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span></span><br><span class="line">5f515359c7f8: redis</span><br><span class="line">05a60462f8ba: nginx</span><br><span class="line">fe9198c04d62: mongo</span><br><span class="line">00285df0df87: &lt;none&gt;</span><br><span class="line">329ed837d508: ubuntu</span><br><span class="line">329ed837d508: ubuntu</span><br></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span></span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">5f515359c7f8        redis               latest</span><br><span class="line">05a60462f8ba        nginx               latest</span><br><span class="line">fe9198c04d62        mongo               3.2</span><br><span class="line">00285df0df87        &lt;none&gt;              &lt;none&gt;</span><br><span class="line">329ed837d508        ubuntu              18.04</span><br><span class="line">329ed837d508        ubuntu              bionic</span><br></pre></td></tr></table></figure><h1 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3 删除本地镜像"></a>3 删除本地镜像</h1><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h2 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h2><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --digests</span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">rm</span> node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h2 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h2><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h2 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h2><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p><h1 id="4-利用-commit-理解镜像构成"><a href="#4-利用-commit-理解镜像构成" class="headerlink" title="4 利用 commit 理解镜像构成"></a>4 利用 commit 理解镜像构成</h1><blockquote><p>注意：如果您是初学者，您可以暂时跳过后面的内容，直接学习 <a href="https://yeasy.gitbook.io/docker_practice/container">容器</a> 一节。</p></blockquote><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。如果你想要定制镜像请查看下一小节。</p><p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。</p><p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在本机运行的 Docker，那么可以直接访问：<code>http://localhost</code> ，如果是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it webserver bash</span><br><span class="line">root@3729b97e8226:/<span class="comment"># echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root@3729b97e8226:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker diff webserver</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br><span class="line">C /run</span><br><span class="line">C /usr</span><br><span class="line">C /usr/share</span><br><span class="line">C /usr/share/nginx</span><br><span class="line">C /usr/share/nginx/html</span><br><span class="line">C /usr/share/nginx/html/index.html</span><br><span class="line">C /var</span><br><span class="line">C /var/cache</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/client_temp</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br></pre></td></tr></table></figure><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>我们可以用下面的命令将容器保存为镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">    [-a]--author <span class="string">&quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot;</span> \</span><br><span class="line">    [-m]--message <span class="string">&quot;修改了默认网页&quot;</span> \</span><br><span class="line">    <span class="comment"># [-c] list # apply dockerfile instruction to the created image</span></span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> nginx</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v2                  07e334659748        9 seconds ago       181.5 MB</span><br><span class="line">nginx               1.11                05a60462f8ba        12 days ago         181.5 MB</span><br><span class="line">nginx               latest              e43d811ce2f4        4 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> nginx:v2</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">07e334659748        54 seconds ago      nginx -g daemon off;                            95 B                修改了默认网页</span><br><span class="line">e43d811ce2f4        4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon    0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  EXPOSE 443/tcp 80/tcp        0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="built_in">ln</span> -sf /dev/stdout /var/log/nginx/   22 B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   58.46 MB</span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  MAINTAINER NGINX Docker Ma   0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0 B</span></span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop) ADD file:23aa4f893e3288698c   123 MB</span></span><br></pre></td></tr></table></figure><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。访问 <code>http://localhost:81</code> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 <code>docker commit</code></h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。<strong>如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</strong></p><h1 id="5-使用-Dockerfile-定制镜像"><a href="#5-使用-Dockerfile-定制镜像" class="headerlink" title="5 使用 Dockerfile 定制镜像"></a>5 使用 Dockerfile 定制镜像</h1><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)<strong>，</strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ <span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外<strong>，Docker 还存在一个特殊的镜像，名为 <code>scratch</code><strong>。这个镜像是虚拟的概念，并不实际存在，它</strong>表示一个空白的镜像</strong>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p></li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <strong><code>RUN</code> 的行为</strong>，就和刚才我们手工建立镜像的过程一样：<strong>新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像</strong>。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。<strong>Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式</strong>。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running in 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。<strong>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具</strong>。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <strong><code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎</strong>的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如**可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>**。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h2><h3 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h3><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $env:DOCKER_BUILDKIT=0</span></span><br><span class="line"><span class="comment"># export DOCKER_BUILDKIT=0</span></span><br><span class="line"></span><br><span class="line">$ docker build -t hello-world https://github.com/docker-library/hello-world.git<span class="comment">#master:amd64/hello-world</span></span><br><span class="line"></span><br><span class="line">Step 1/3 : FROM scratch</span><br><span class="line"> ---&gt;</span><br><span class="line">Step 2/3 : COPY hello /</span><br><span class="line"> ---&gt; ac779757d46e</span><br><span class="line">Step 3/3 : CMD [<span class="string">&quot;/hello&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d2a513a760ed</span><br><span class="line">Removing intermediate container d2a513a760ed</span><br><span class="line"> ---&gt; 038ad4142d2b</span><br><span class="line">Successfully built 038ad4142d2b</span><br></pre></td></tr></table></figure><p>这行命令指定了构建所需的 Git repo，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h3 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h3 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h3 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h1 id="6-Dockerfile-指令详解"><a href="#6-Dockerfile-指令详解" class="headerlink" title="6 Dockerfile 指令详解"></a>6 Dockerfile 指令详解</h1><p>我们已经介绍了 <code>FROM</code>，<code>RUN</code>，还提及了 <code>COPY</code>, <code>ADD</code>，其实 <code>Dockerfile</code> 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。</p><blockquote><p>Docker 镜像由多个只读层组成，每个层都对应 Dockerfile 中的一个指令。以下这些 Dockerfile 指令将会创建新的层：</p><ol><li><code>RUN</code>：每个 <code>RUN</code> 命令都会在镜像中创建一个新的层。由于这让镜像变得较大，因此常常会看到多个 <code>RUN</code> 命令链在一起以减少创建的层数。</li><li><code>COPY</code>：<code>COPY</code> 指令会将文件或目录从 Docker 构建上下文复制到新的一层上，然后将它们添加到 Dockerfile 中所指定的路径。</li><li><code>ADD</code>：就像 <code>COPY</code> 一样, <code>ADD</code> 指令会在一个新的层上复制文件，并对文件（如果是压缩的话，会进行自动解压缩）进行提取。另一方面，由于 <code>ADD</code> 命令有些额外的功能（比如能下载远程的 URLs），通常建议在文件复制时尽量使用 <code>COPY</code>。</li><li><code>WORKDIR</code>：如果指定的工作目录不存在，这个命令将会创建该目录，并在新的层上创建。</li><li><code>VOLUME</code>: 此命令也会在 Docker 镜像中创建新的层。</li><li><code>USER</code>：此命令用于设定下一条 <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code> 指令运行时的 UID。</li><li><code>LABEL</code>：此命令添加元数据到镜像，创建一个新的层。</li></ol><p>虽然 <code>ENTRYPOINT</code> 和 <code>CMD</code> 指定了容器的默认执行命令，但它们不会创建新的层，因为它们不会改变镜像的文件系统。同样，<code>ENV</code> 指令用来设置环境变量，也不会创建新的镜像层。</p><p>这就是 Dockerfile 中用来创建新层的主要指令, 使用合理可有效改进创建的 Docker 镜像的大小和构建时间。</p></blockquote><h2 id="6-1-COPY-复制文件"><a href="#6-1-COPY-复制文件" class="headerlink" title="6.1 COPY 复制文件"></a>6.1 COPY 复制文件</h2><p>格式：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p><h2 id="6-2-ADD-更高级的复制文件"><a href="#6-2-ADD-更高级的复制文件" class="headerlink" title="6.2 ADD 更高级的复制文件"></a>6.2 ADD 更高级的复制文件</h2><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p><p>在 Docker 官方的 <a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure><h2 id="6-3-CMD-容器启动命令"><a href="#6-3-CMD-容器启动命令" class="headerlink" title="6.3 CMD 容器启动命令"></a>6.3 CMD 容器启动命令</h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。**<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的**。</p><p><strong>在运行时可以指定新的命令来替代镜像设置中的这个默认命令</strong>，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p><strong>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</strong></p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$HOME</span>&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> service nginx start</span></span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p>而使用 <code>service nginx start</code> 命令，则是希望 init 系统以后台守护进程的形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="6-4-ENTRYPOINT-入口点"><a href="#6-4-ENTRYPOINT-入口点" class="headerlink" title="6.4 ENTRYPOINT 入口点"></a>6.4 ENTRYPOINT 入口点</h2><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。**<code>ENTRYPOINT</code> 在运行时也可以替代<strong>，不过比 <code>CMD</code> 要略显繁琐，</strong>需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定**。</p><p><strong>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令</strong>，换句话说实际执行时，将变为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in <span class="variable">$PATH</span>\&quot;\n&quot;</span>.</span><br></pre></td></tr></table></figure><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http://myip.ipip.net -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，<strong>可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行</strong>。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">find . \! -user redis -<span class="built_in">exec</span> <span class="built_in">chown</span> redis <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line"><span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br></pre></td></tr></table></figure><h2 id="6-5-ENV-设置环境变量"><a href="#6-5-ENV-设置环境变量" class="headerlink" title="6.5 ENV 设置环境变量"></a>6.5 ENV 设置环境变量</h2><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span> DEBUG=on \</span><br><span class="line">    NAME=<span class="string">&quot;Happy Feet&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span></span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p><p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h2 id="6-6-ARG-构建参数"><a href="#6-6-ARG-构建参数" class="headerlink" title="6.6 ARG 构建参数"></a>6.6 ARG 构建参数</h2><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，**<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的<strong>。但是</strong>不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的**。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。<strong>该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</strong>。</p><p><strong>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像</strong>。</p><p><strong>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中</strong>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure><p>使用上述 Dockerfile 会发现无法输出 <code>$&#123;DOCKER_USERNAME&#125;</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只在 FROM 中生效</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure><p>对于多阶段构建，尤其要注意这个问题：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个变量在每个 FROM 中都生效</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 2</span></span><br></pre></td></tr></table></figure><p>对于上述 Dockerfile 两个 <code>FROM</code> 指令都可以使用 <code>$&#123;DOCKER_USERNAME&#125;</code>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="6-7-VOLUME-定义匿名卷"><a href="#6-7-VOLUME-定义匿名卷" class="headerlink" title="6.7 VOLUME 定义匿名卷"></a>6.7 VOLUME 定义匿名卷</h2><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前我们说过，<strong>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)<strong>中，后面的章节我们会进一步介绍 Docker 卷的概念。</strong>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据</strong>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span><span class="language-bash"> -d -v mydata:/data xxxx</span></span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><blockquote><p>当你在 Dockerfile 中使用 <code>VOLUME</code> 指令或者在运行容器时通过 <code>-v</code> 标记创建一个匿名卷时，Docker 会自动在宿主机上为该卷分配一个存储位置。<strong>这个位置是由 Docker 的配置和宿主机操作系统决定的</strong>，并且通常不是直接由用户指定的。对于大多数 Linux 安装和 Docker 的默认配置，<strong>匿名卷的存储位置是在宿主机的 <code>/var/lib/docker/volumes/</code> 目录下</strong>。</p><p>在该目录下，每个卷都会有一个唯一的标识符作为其目录名。在这些卷的目录内部，你会找到两个子目录：<code>_data</code>，其中存储的是卷的数据，以及 <code>mounts.json</code>，其中包含有关该卷的元数据。</p><p>例如，若你通过 Docker 命令创建了一个匿名卷，你可能会在 <code>/var/lib/docker/volumes/</code> 下找到一个类似于 <code>/var/lib/docker/volumes/2f4a8c1d591f396c2b47e6b42dfea9184292ab09e78a0b3e7661e8a3ef4b0c82/</code> 的目录，<code>_data</code> 文件夹就在这个目录里。</p><p>需要注意的是，不同的 Docker 配置和不同的宿主机操作系统可能会改变这个默认的存储位置。此外，出于安全和维护的目的，不鼓励直接手动操作这些文件目录。对于大多数用例，建议使用 Docker 命令来管理和操作卷。</p><p>若需要查询卷的具体存储位置，可以使用 Docker 卷命令，如 <code>docker volume inspect [VOLUME_NAME]</code>，它会显示卷的详细信息，包括其在宿主机上的确切存储路径。对于匿名卷，虽然没有友好的名称，但每个都有一个唯一的ID，可以通过列出所有卷的信息 <code>docker volume ls</code> 来找到，然后用这个 ID 进行检查。</p></blockquote><h2 id="6-8-EXPOSE-暴露端口"><a href="#6-8-EXPOSE-暴露端口" class="headerlink" title="6.8 EXPOSE 暴露端口"></a>6.8 EXPOSE 暴露端口</h2><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>**EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务**。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p><strong>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射</strong>。</p><blockquote><p>在 Docker 中，<code>-p</code> 和 <code>-P</code> 标志被用来将容器内部的端口映射到宿主机的端口上，但它们的工作方式存在一些区别：</p><ol><li><strong><code>-p</code> 标志</strong>:<ul><li>使用 <code>-p</code> 标志时，你需要明确指定端口映射关系。这包括宿主机的端口和容器内部的端口，格式为 <code>-p 宿主机端口:容器端口</code>。</li><li>例如，<code>docker run -p 8080:80 nginx</code> 会将容器内部的 80 端口映射到宿主机的 8080 端口。</li><li>你可以精确控制端口映射的过程，包括选择特定的宿主机端口。</li></ul></li><li><strong><code>-P</code> 标志</strong>:<ul><li>使用 <code>-P</code> 标志时，Docker 会自动将容器内部所有通过 <code>EXPOSE</code> 指令暴露出来的端口映射到宿主机的一个随机高端口（通常在 49153 到 65535 之间）。</li><li>这意味着你无法控制端口映射到宿主机的哪个端口上，端口号是由 Docker 动态分配的。</li><li>例如，<code>docker run -P nginx</code> 假设你的 nginx 镜像通过 <code>EXPOSE</code> 指令暴露了 80 端口，Docker 将自动选择一个端口将其映射到宿主机。</li></ul></li></ol></blockquote><h2 id="6-9-WORKDIR-指定工作目录"><a href="#6-9-WORKDIR-指定工作目录" class="headerlink" title="6.9 WORKDIR 指定工作目录"></a>6.9 WORKDIR 指定工作目录</h2><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p><strong>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录</strong>。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而<strong>在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器</strong>。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p><strong>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关</strong>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p><h2 id="6-10-USER-指定当前用户"><a href="#6-10-USER-指定当前用户" class="headerlink" title="6.10 USER 指定当前用户"></a>6.10 USER 指定当前用户</h2><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p><p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="keyword">USER</span> redis</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h1 id="7-Dockerfile多阶段构建"><a href="#7-Dockerfile多阶段构建" class="headerlink" title="7 Dockerfile多阶段构建"></a>7 Dockerfile多阶段构建</h1><p><strong>将所有的构建过程编包含在一个 <code>Dockerfile</code> 中</strong>，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p><ul><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄露的风险</li></ul><p><strong>事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中</strong>，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，<strong>但明显部署过程较复杂</strong>。</p><p>例如，编写 <code>Dockerfile.build</code> 文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br></pre></td></tr></table></figure><p>编写 <code>Dockerfile.copy</code> 文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>新建 <code>build.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:build</span><br><span class="line"></span><br><span class="line">docker build -t go/helloworld:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker <span class="built_in">cp</span> extract:/go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker <span class="built_in">rm</span> -f extract</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:2</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy</span><br><span class="line"><span class="built_in">rm</span> ./app</span><br></pre></td></tr></table></figure><p>现在运行脚本即可构建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x build.sh</span><br><span class="line"></span><br><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure><p>对比两种方式生成的镜像大小</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</span><br><span class="line">go/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB</span><br><span class="line">go/helloworld   1      f55d3e16affc    2 minutes ago   295MB</span><br></pre></td></tr></table></figure><h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p><p>例如，编写 <code>Dockerfile</code> 文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure><p>对比三个镜像大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</span><br><span class="line">go/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB</span><br><span class="line">go/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB</span><br><span class="line">go/helloworld     1     f55d3e16affc     2 minutes ago      295MB</span><br></pre></td></tr></table></figure><p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p><h3 id="只构建某一阶段的镜像"><a href="#只构建某一阶段的镜像" class="headerlink" title="只构建某一阶段的镜像"></a>只构建某一阶段的镜像</h3><p>我们<strong>可以使用 <code>as</code> 来为某一阶段命名</strong>，例如</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br></pre></td></tr></table></figure><p>例如当我们<strong>只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure><h3 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h3><p>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-Docker命令简介&quot;&gt;&lt;a href=&quot;#0-Docker命令简介&quot; class=&quot;headerlink&quot; title=&quot;0 Docker命令简介&quot;&gt;&lt;/a&gt;0 Docker命令简介&lt;/h1&gt;&lt;img src=&quot;./memo_usage/docker.png</summary>
      
    
    
    
    <category term="tools" scheme="https://stu-yue.github.io/categories/tools/"/>
    
    <category term="docker" scheme="https://stu-yue.github.io/categories/tools/docker/"/>
    
    
    <category term="docker" scheme="https://stu-yue.github.io/tags/docker/"/>
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Shell Basis</title>
    <link href="https://stu-yue.github.io/jottings/languages/shell/memo_shell_basis/"/>
    <id>https://stu-yue.github.io/jottings/languages/shell/memo_shell_basis/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-04-16T08:50:47.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-交互式登录-shell-和非登录-shell"><a href="#0-交互式登录-shell-和非登录-shell" class="headerlink" title="0 交互式登录 shell 和非登录 shell"></a>0 交互式登录 shell 和非登录 shell</h2><p>交互式登录 shell 和非登录 shell 是两种在 Linux 系统中使用 Shell 时的不同环境。它们有以下区别：</p><p>交互式登录 shell：</p><ul><li>当用户通过登录界面（例如终端登录、SSH 远程登录）成功登录到系统时，系统会为用户启动一个交互式登录 shell。</li><li>交互式登录 shell 会读取系统的登录配置文件（如 <code>/etc/profile</code> 和 <code>~/.bash_profile</code>）来执行初始化操作，设置环境变量、加载别名和执行其他登录时需要的配置。</li><li>它还会执行 <code>~/.bashrc</code> 文件，以便加载用户自定义的 Shell 配置。</li><li>用户在交互式登录 shell 中执行的命令会被记录到历史记录文件（如 <code>~/.bash_history</code>）中。</li></ul><p>非登录 shell：</p><ul><li>当用户已经登录到系统后，在当前 shell 中打开一个新的终端或运行脚本时，会启动一个非登录 shell。</li><li>非登录 shell 不会读取登录配置文件（如 <code>/etc/profile</code> 和 <code>~/.bash_profile</code>），而是读取 <code>~/.bashrc</code> 文件进行初始化。</li><li>它不会执行登录时需要的配置，只会加载用户自定义的 Shell 配置。</li><li>用户在非登录 shell 中执行的命令不会被记录到历史记录文件中，除非用户在 <code>~/.bashrc</code> 中显式地指定。</li></ul><p>大部分Linux发行版用<code>~/.profile</code>替换<code>~/.bash_profile</code>，<code>~/.profile</code>被所有shell读取，<code>~\.bash_profile</code>仅被Bash读取；</p><p><code>.profile</code>在登录shell启动时，被读取和执行；<code>.bashrc</code>在非登录shell启动时执行；</p><blockquote><p><code>profile</code>中会读取各自级别的<code>bashrc</code>；</p><p>Shell启动时读取配置文件的顺序：</p><ol><li><code>/etc/profile</code></li><li><code>/etc/profile.d/*.sh</code></li><li><code>/etc/bash.bashrc</code></li><li><code>~/.profile</code> 或 <code>~/.bash_login</code> 或 <code>~/.bash_profile</code>：个性化环境变量设置</li><li><code>~/.bashrc</code> ：别名、函数和其他个性化设置；</li></ol></blockquote><table><thead><tr><th align="center"></th><th align="center">系统级</th><th align="center">用户级</th></tr></thead><tbody><tr><td align="center">登录shell</td><td align="center">&#x2F;etc&#x2F;profile</td><td align="center">~&#x2F;.profile  | ~&#x2F;.bash_profile</td></tr><tr><td align="center">非登录shell</td><td align="center">&#x2F;etc&#x2F;bash.bashrc</td><td align="center">~&#x2F;.bashrc</td></tr></tbody></table><h5 id="登录式-shell-和非登录式-shell-的运行形式如下："><a href="#登录式-shell-和非登录式-shell-的运行形式如下：" class="headerlink" title="登录式 shell 和非登录式 shell 的运行形式如下："></a>登录式 shell 和非登录式 shell 的运行形式如下：</h5><ul><li>登录式 shell：<ul><li>正常通过某终端登录的 shell。</li><li>su - username。</li><li>su -l username。</li></ul></li><li>非登录式 shell：<ul><li>su username。</li><li><strong>图形终端</strong>下打开的命令窗口。</li><li>自动执行的 shell 脚本。</li></ul></li></ul><p>**<code>echo $0</code>**：<code>-bash</code>登录shell；<code>bash</code>非登录；</p><h2 id="1-结合Linux文件描述符理解重定向"><a href="#1-结合Linux文件描述符理解重定向" class="headerlink" title="1 结合Linux文件描述符理解重定向"></a>1 结合Linux文件描述符理解重定向</h2><blockquote><p><strong>输入输出重定向就是通过修改文件指针实现的</strong>。发生重定向时，文件描述符并没有改变，改变的是文件描述符对应的文件指针。</p></blockquote><p><strong>Shell对文件描述符的操作</strong></p><table><thead><tr><th align="center">分类</th><th align="center">用法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">输出</td><td align="center">n&gt;filename</td><td align="center">以输出的方式打开文件 filename，并绑定到文件描述符 n。n 可以不写，默认为 1，也即标准输出文件。</td></tr><tr><td align="center">输出</td><td align="center">n&gt;&amp;m</td><td align="center">用文件描述符 m 修改文件描述符 n，或者说用文件描述符 m 的内容覆盖文件描述符 n，结果就是 n 和 m 都代表了同一个文件，因为 n 和 m 的文件指针都指向了同一个文件。因为使用的是<code>&gt;</code>，所以 n 和 m 只能用作命令的输出文件。n 可以不写，默认为 1。</td></tr><tr><td align="center">输出</td><td align="center">n&gt;&amp;-</td><td align="center">关闭文件描述符 n 及其代表的文件。n 可以不写，默认为 1。在shell中执行<code>&gt;&amp;-</code>命令会关闭文件描述符。具体来说，它会关闭标准输出（文件描述符1）和标准错误输出（文件描述符2），将它们都重定向到空设备（&#x2F;dev&#x2F;null）。</td></tr><tr><td align="center">输出</td><td align="center">&amp;&gt;filename</td><td align="center">这个操作可以用于临时禁用命令的输出，以防止输出被显示或记录。将正确输出结果和错误信息全部重定向到 filename。</td></tr><tr><td align="center">输入</td><td align="center">n&lt;filename</td><td align="center">以输入的方式打开文件 filename，并绑定到文件描述符 n。n 可以不写，默认为 0，也即标准输入文件。</td></tr><tr><td align="center">输入</td><td align="center">n&lt;&amp;m</td><td align="center">类似于 n&gt;&amp;m，但是因为使用的是<code>&lt;</code>，所以 n 和 m 只能用作命令的输入文件。n 可以不写，默认为 0。</td></tr><tr><td align="center">输入</td><td align="center">n&lt;&amp;-</td><td align="center">关闭文件描述符 n 及其代表的文件。n 可以不写，默认为 0。</td></tr><tr><td align="center">输入和输出</td><td align="center">n&lt;&gt;filename</td><td align="center">同时以输入和输出的方式打开文件 filename，并绑定到文件描述符 n，相当于 n&gt;filename 和 n&lt;filename 的总和。。n 可以不写，默认为 0。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;C语言中文网&quot; 10&gt;log.txt &gt;&amp;10</span><br></pre></td></tr></table></figure><p>先执行<code>10&gt;log.txt</code>，打开 log.txt，并给它分配文件描述符 10；接着执行<code>&gt;&amp;10</code>，用文件描述符 10 来修改文件描述符 1（对于<code>&gt;</code>，省略不写的话默认为 1），让 1 和 10 都指向 log.txt 文件，最终的结果是向 log.txt 文件中输出内容。</p><p>这条语句其实等价于<code>echo &quot;C语言中文网&quot; &gt;log.txt</code>，我之所以写得这么绕，是为了让大家理解各种操作符的用法。</p><p>文件描述符 10 只用了一次，我们在末尾最好将它关闭，这是一个好习惯。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;C语言中文网&quot; 10&gt;log.txt &gt;&amp;10 10&gt;&amp;-</span><br></pre></td></tr></table></figure><h2 id="2-管道-pipeline"><a href="#2-管道-pipeline" class="headerlink" title="2 管道(pipeline,  |  )"></a>2 管道(pipeline,  |  )</h2><p>pipeline ( | ) 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who | wc -l</span><br></pre></td></tr></table></figure><p>善用这个观念，对精简 script 有相当的帮助。</p><h2 id="3-后台工作-amp"><a href="#3-后台工作-amp" class="headerlink" title="3 后台工作(  &amp;  )"></a>3 后台工作(  &amp;  )</h2><p>单一个&amp; 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。</p><ul><li><p>nohup重定向到指定文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./run &gt;log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-快速入门"><a href="#4-快速入门" class="headerlink" title="4 快速入门"></a>4 快速入门</h2><ul><li><code>#!</code>:  Shebang line，告诉系统脚本用什么解释器执行；<ul><li><code>.sh</code>作为可执行程序时，加上第一行；</li></ul></li><li><code>sh</code> （默认Shell解释器运行）、<code>bash</code>（bash解释器执行）；</li></ul><h2 id="5-基本语法（变量）"><a href="#5-基本语法（变量）" class="headerlink" title="5 基本语法（变量）"></a>5 基本语法（变量）</h2><ul><li><p><strong>定义变量：</strong>变量名&#x3D;变量值，等号两侧不能有空格，变量名一般习惯用大写。</p></li><li><p><strong>删除变量：</strong>unset 变量名 。</p></li><li><p><strong>声明静态变量：</strong>readonly 变量名，静态变量不能unset。</p></li><li><p><strong>使用变量：</strong>$变量名</p></li><li><p>**命令替换<code>$()</code>**：将命令返回值赋给变量；等价于反引号；</p></li><li><p><strong>环境变量</strong>：</p><ul><li>export 变量名&#x3D;变量值，将 Shell 变量输出为环境变量；</li><li>source 配置文件路径，让修改后的配置信息立即生效；</li><li>echo $变量名，检查环境变量是否生效；</li></ul></li><li><p><strong>位置参数</strong>：</p><ul><li><code>$n</code> ：<code>$0</code> 代表命令本身、<code>$1</code>-<code>$9</code> 代表第1到9个参数，10以上参数用花括号，如 ${10}。</li><li>$* ：命令行中所有参数，且把所有参数看成一个整体。</li><li>$@ ：命令行中所有参数，且把每个参数区分对待（推荐）。</li><li>$# ：所有参数个数。</li></ul><blockquote><p><em><em>$</em> 和 $@，在不被双引号包围时</em>*，行为十分相似——都会将脚本的所有参数展开成一个由空格分隔的列表。在这种情况下，参数中包含的空格或特殊字符可能不会被正确处理，并可能会引起词语分割，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// study.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line"></span><br><span class="line">// run</span><br><span class="line">./study.sh one <span class="string">&quot;two two&quot;</span> three</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">one two two three</span><br></pre></td></tr></table></figure><p><em><em>$</em> 和 $@，在被双引号包围时</em>*，</p><p>$@ 会将每个参数作为独立且被引号包围的字符串，保持其作为单独的元素，会正确处理包含空格&#x2F;特殊字符的参数；</p><p>$* 会将所有参数连成一个单独的字符串，其中的参数由空格分隔，这种方式不能保证原有参数的准确界限，尤其是参数内部包含空格时。</p></blockquote></li><li><p><strong>预定义变量</strong></p><ul><li><strong>$$</strong>：当前进程的PID；</li><li>**$!**：后台运行的最后一个进程的PID；</li><li>**$?**：最后一次执行命令的返回状态，0为成功；</li></ul></li><li><p><strong>运算式计算</strong></p><ul><li><code>$(())</code>：<code>$((2+3*2))</code></li><li><code>$(expr 2 + 3)</code>：</li></ul></li><li><p><strong>条件判断</strong></p><ul><li><p><code>[ condition ]</code>：前后都要有空格，非空返回0，0为true；否则为false；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="keyword">elif</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><table><thead><tr><th align="center">测试参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>str</code></td><td align="center">字符串 <code>str</code> 非空</td></tr><tr><td align="center"><code>-z str</code></td><td align="center">字符串 <code>str</code> 为空</td></tr><tr><td align="center"><code>-n str</code></td><td align="center">字符串 <code>str</code> 的长度非零</td></tr><tr><td align="center"><code>str1=str2</code></td><td align="center"></td></tr><tr><td align="center"><code>str1!=str2</code></td><td align="center"></td></tr><tr><td align="center"><code>-e file</code></td><td align="center">文件 <code>file</code> 存在</td></tr><tr><td align="center"><code>-f file</code></td><td align="center">文件 <code>file</code> 存在且是一个普通文件</td></tr><tr><td align="center"><code>-d dir</code></td><td align="center">文件 <code>dir</code> 存在且是一个目录</td></tr><tr><td align="center"><code>-r/w/x file</code></td><td align="center">文件 <code>file</code> 存在且可读&#x2F;可写&#x2F;可执行</td></tr><tr><td align="center"><code>-s file</code></td><td align="center">文件 <code>file</code> 存在且文件大小不为0</td></tr><tr><td align="center"><code>num1 -eq/ne/lt/le/ge/gt num2</code></td><td align="center"></td></tr><tr><td align="center"><code>[ ! condition ]</code></td><td align="center"></td></tr><tr><td align="center"><code>[ cond1 -a cond2]</code></td><td align="center">[[ cond1 &amp;&amp; cond2]]</td></tr><tr><td align="center"><code>[ cond1 -o cond2 ]</code></td><td align="center">[[ cond1 || cond2 ]]</td></tr></tbody></table></li></ul></li><li><p><strong>case分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$var</span> <span class="keyword">in</span></span><br><span class="line">c1)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c1&quot;</span></span><br><span class="line">;;</span><br><span class="line">c2)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c2&quot;</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p><strong>for循环</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> (...); <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..20&#125;; <span class="keyword">do</span> <span class="keyword">if</span> [ $((i % <span class="number">2</span>)) -eq 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">fi</span>; <span class="keyword">done</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔2个数打印一次</span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; i+=<span class="number">2</span>)); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 2 10); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>while循环</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 20 ]; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span>; i=$((i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">done</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>读取控制台输入 (read)</strong></p><ul><li><p><code>-p</code>：指定读取值时的提示符；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个数num=&quot;</span> NUM; <span class="built_in">echo</span> <span class="string">&quot;num=<span class="variable">$NUM</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>-t</code>：指定读取值时等待秒数，如果没有指定时间内输入，不再等待；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -t 5 -p <span class="string">&quot;请5s内输入一个数num=&quot;</span> NUM; <span class="built_in">echo</span> <span class="string">&quot;num=<span class="variable">$NUM</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><ul><li><p><strong>系统函数</strong>：</p></li><li><p><strong>自定义函数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">function_name</span></span>() &#123;</span><br><span class="line"><span class="comment"># Your commands here</span></span><br><span class="line">[<span class="built_in">return</span> value] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="function"><span class="title">check_file_exists</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File exists.&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File does not exist.&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数并传递文件名</span></span><br><span class="line">check_file_exists <span class="string">&quot;/path/to/your/file.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取函数返回值</span></span><br><span class="line">status=$?</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据返回值判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$status</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The check confirmed that the file exists.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The check confirmed that the file does NOT exist.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>可以使用<strong>局部变量</strong>（声明和赋值应该在不同行），将位置参数赋予更有意义的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print_details</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> name=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> age=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">local</span> job_title=<span class="variable">$3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Name: <span class="variable">$name</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Age: <span class="variable">$age</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Job Title: <span class="variable">$job_title</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数并传递参数</span></span><br><span class="line">print_details <span class="string">&quot;Alice&quot;</span> <span class="string">&quot;30&quot;</span> <span class="string">&quot;Developer&quot;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-交互式登录-shell-和非登录-shell&quot;&gt;&lt;a href=&quot;#0-交互式登录-shell-和非登录-shell&quot; class=&quot;headerlink&quot; title=&quot;0 交互式登录 shell 和非登录 shell&quot;&gt;&lt;/a&gt;0 交互式登录 shell </summary>
      
    
    
    
    <category term="languages" scheme="https://stu-yue.github.io/categories/languages/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/categories/languages/shell/"/>
    
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Tmux</title>
    <link href="https://stu-yue.github.io/jottings/languages/shell/memo_tmux/"/>
    <id>https://stu-yue.github.io/jottings/languages/shell/memo_tmux/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-01-06T15:10:12.480Z</updated>
    
    <content type="html"><![CDATA[<h4 id="What-is-tmux"><a href="#What-is-tmux" class="headerlink" title="What is tmux?"></a>What is tmux?</h4><ul><li><p>A typical use of the command line is to open a terminal window (session), whose important feature is that window is connected to the process started in it (window closed, session ends, vice versa).</p></li><li><p><strong>Tmux,</strong> Terminal multiplexer, is  the session and window “unbind” tool. It allows:</p><ul><li>simultaneous access to multiple sessions in a single window. (useful for running multiple terminal simultaneously)</li><li>a new window to  access an existing session;</li><li>each session having multiple connection window (multiple people sharing sessions in real time)</li><li>arbitrary vertical and horizontal splitting of windows;</li></ul></li><li><p>Basic conception:</p><ul><li>session:</li></ul><img src="./memo_tmux/tmux_basic.png" style="zoom:50%"><img src="./tmux_basic.png" style="zoom:50%"></li></ul><h4 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h4><ul><li><p>Start —<code>tmux</code>, Quit—<code>exit/Ctrl-d</code>, Prefix Key—<code>Ctrl+b</code>;</p></li><li><p>A status bar is located at the bottom:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[name/id] [list of ]</span><br><span class="line">[0] 0:bash  1:test3* 2:test4-         &quot;VM-16-17-ubuntu&quot; 15:28 04-Oct-23</span><br></pre></td></tr></table></figure></li></ul><h4 id="Session-Management"><a href="#Session-Management" class="headerlink" title="Session Management"></a>Session Management</h4><ul><li><p>New a session: <code>tmux new -s &lt;session-name&gt;</code>; </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s sessionName -n window</span><br></pre></td></tr></table></figure></li><li><p>Split sessions: <code>tmux detach/Ctrl+b d</code>, after the command is executed, the current Tmux window exits, but the session and the processes inside it still run in the background;</p></li><li><p>View all current tmux sessions: <code>tmux ls</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: 1 windows (created Tue Sep 19 20:42:24 2023)</span><br><span class="line">1: 1 windows (created Tue Oct  3 19:57:48 2023)</span><br><span class="line">test2: 1 windows (created Wed Oct  4 14:49:04 2023) (attached)</span><br></pre></td></tr></table></figure></li><li><p>Attach a session: <code>tmux attach -t id/&lt;session-name&gt;</code>;</p></li><li><p>Kill a session: <code>tmux kill-session -t id/&lt;session-name&gt;</code>;</p></li><li><p>Switch a session: <code>tmux switch -t id/&lt;session-name&gt;</code>;</p></li><li><p>Rename a session: <code>tmux rename-session -t id/&lt;session-name&gt; &lt;new-name&gt;</code>;</p></li><li><p>Shortcuts: </p><ul><li><code>Ctrl+b</code>d: Split current session;</li><li><strong><code>Ctrl+b s</code> list all session;</strong></li><li><strong><code>Ctrl+b w</code> list all windows;</strong></li><li><code>Ctrl+b $</code>: rename current session;</li></ul></li><li><p>Simple workflow of tmux:</p><ol><li>new a session: <code>tmux new -s my_session</code>;</li><li>run program in tmux window;</li><li><code>Ctrl+b d</code> splits the session;</li><li>Attach the last session <code>tmux attach-session -t my_session</code>;</li></ol></li></ul><h4 id="Pane-Operation"><a href="#Pane-Operation" class="headerlink" title="Pane Operation"></a>Pane Operation</h4><p>Tmux can split the window into panes, which can execute different commands.</p><ul><li><p><code>tmux splilt-window</code> splits into vertical layout;</p></li><li><p><code>tmux split-window -h</code> splits into horizontal layout;</p></li><li><p><code>tmux select-pane</code> moves the cursor in different panes:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到上方窗格</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -U</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到下方窗格</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -D</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到左边窗格</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -L</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标切换到右边窗格</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -R</span></span><br></pre></td></tr></table></figure></li><li><p><code>tmux swap-pane</code> exchanges the positions of panes:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前窗格上移</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux swap-pane -U</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前窗格下移</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux swap-pane -D</span></span><br></pre></td></tr></table></figure></li><li><p>Shortcuts in pane operations:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b %：划分左右两个窗格。</span><br><span class="line">Ctrl+b &quot;：划分上下两个窗格。</span><br><span class="line">Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span><br><span class="line">Ctrl+b ;：光标切换到上一个窗格。</span><br><span class="line">Ctrl+b o：光标切换到下一个窗格。</span><br><span class="line">Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span><br><span class="line">Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span><br><span class="line">Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span><br><span class="line">Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span><br><span class="line">Ctrl+b x：关闭当前窗格。</span><br><span class="line">Ctrl+b !：将当前窗格拆分为一个独立窗口。</span><br><span class="line">Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span><br><span class="line">Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span><br><span class="line">Ctrl+b q：显示窗格编号。</span><br></pre></td></tr></table></figure></li><li><p>Close window&#x2F;pane</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></li></ul><h4 id="Window-Operation"><a href="#Window-Operation" class="headerlink" title="Window Operation"></a>Window Operation</h4><ul><li><p><code>tmux new-window -n &lt;window-name&gt;</code>: new a window;</p></li><li><p><code>tmux select-window -t &lt;window-number/name&gt;</code>: switch window</p></li><li><p><code>tmux rename-window</code></p></li><li><p>Shortcuts in window operation:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。</span><br><span class="line">Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。</span><br><span class="line">Ctrl+b n：切换到下一个窗口。</span><br><span class="line">Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。</span><br><span class="line">Ctrl+b w：从列表中选择窗口。</span><br><span class="line">Ctrl+b ,：窗口重命名。</span><br></pre></td></tr></table></figure></li></ul><h4 id="Other-Commands"><a href="#Other-Commands" class="headerlink" title="Other Commands"></a>Other Commands</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有快捷键，及其对应的 Tmux 命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux list-keys</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有 Tmux 命令及其参数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux list-commands</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前所有 Tmux 会话的信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux info</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用快捷键</span></span><br><span class="line">Ctrl+b s列出所有sessions信息</span><br><span class="line">Ctrl+b w</span><br><span class="line">Ctrl+b o切换窗格</span><br><span class="line">Ctrl+b n切换窗口</span><br><span class="line">Ctrl+b d分离session</span><br><span class="line"></span><br><span class="line">tmux new [-t xx [-n xx]]</span><br><span class="line">tmux new-window</span><br><span class="line">tmux split-window [-h]</span><br><span class="line">tmux ls</span><br><span class="line">tmux attach -t xx</span><br><span class="line">tmux detach</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">打开鼠标模式</span><br><span class="line">tmux set mouse on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载当前的 Tmux 配置</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux source-file ~/.tmux.conf</span></span><br><span class="line"></span><br><span class="line">ctrl+b, :  //按完前缀ctrl+B后，再按分号：进入命令行模式</span><br><span class="line">set -g mouse on //命令行中输入这句命令，回车就行了</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名</span></span><br><span class="line">tmux rename-session -t id &lt;new&gt;-t (target)</span><br><span class="line">tmux rename-window -t id &lt;new&gt;</span><br><span class="line"></span><br><span class="line">tmux resize-pane -U/D/L/R 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中复制</span></span><br><span class="line">shift + 左键选中</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;What-is-tmux&quot;&gt;&lt;a href=&quot;#What-is-tmux&quot; class=&quot;headerlink&quot; title=&quot;What is tmux?&quot;&gt;&lt;/a&gt;What is tmux?&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A typical use of th</summary>
      
    
    
    
    <category term="languages" scheme="https://stu-yue.github.io/categories/languages/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/categories/languages/shell/"/>
    
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Here Document</title>
    <link href="https://stu-yue.github.io/jottings/languages/shell/memo_here_doc/"/>
    <id>https://stu-yue.github.io/jottings/languages/shell/memo_here_doc/</id>
    <published>2023-10-04T07:56:53.000Z</published>
    <updated>2024-04-22T09:13:08.227Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><code>tee</code>命令 ：tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p><ul><li><code>-a</code>：追加文件内容，而非覆盖；</li><li><code>-i</code>：忽略中断信号；</li></ul></li><li><p><strong>Here Document</strong>（也称heredoc）是一种在shell中<strong>输入一个或多个行的标准输入文本的方法</strong>。一个Here Document允许用户创建一个有起始标记和终止标记的文本块，该文本块的内容会被当作输入传送给一个命令。</p><ul><li><p>基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt;&lt;<span class="string">DELIMITER</span></span><br><span class="line"><span class="string">text block</span></span><br><span class="line"><span class="string">text block</span></span><br><span class="line"><span class="string">DELIMITER</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本块中的任何以制表符缩进的内容将会在传递给命令之前去除这些制表符缩进</span></span><br><span class="line"><span class="built_in">command</span> &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 带单/双引号后，将不在shell中进行变量替换和命令替换</span></span><br><span class="line"><span class="string">NAME=&quot;World&quot;</span></span><br><span class="line"><span class="string">CURRENT_DATE=$(date)</span></span><br><span class="line"><span class="string">tee /path/to/greeting.txt &lt;&lt;EOF</span></span><br><span class="line">Hello, <span class="variable">$NAME</span>!</span><br><span class="line">Today is <span class="variable">$CURRENT_DATE</span>.</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令 ：tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt;：追加文件内容，而非覆盖；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;：</summary>
      
    
    
    
    <category term="languages" scheme="https://stu-yue.github.io/categories/languages/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/categories/languages/shell/"/>
    
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stu-yue.github.io/jottings/tidbits/quantization/"/>
    <id>https://stu-yue.github.io/jottings/tidbits/quantization/</id>
    <published>2023-09-26T06:40:27.727Z</published>
    <updated>2023-10-08T10:50:28.480Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在线量化：指量化感知训练(Quantization-Aware Training)，在网络模型训练阶段采用量化方案进行量化；</p><ol><li><p>量化感知训练本质上是一种伪量化的过程，它是在可识别的某些操作内嵌入伪量化节点（fake quantization op），并参与模型训练的前向推理过程模拟引入，但模型的反向传播过程依旧使用全精度浮点数进行；</p></li><li><p>伪量化节点，是指量化感知训练中插入的节点，用以寻找网络数据分布，并反馈损失精度：</p><ol><li>找到输入、权重等待量化数据的分布，找到待量化数据的最大和最小值；</li><li>模拟低比特量化带来的精度损失，把该损失作用到网络模型中，传递给损失函数，让优化器在训练过程中对该损失值进行优化， 尽可能减少由于伪量化操作而引起的精度下降；</li></ol></li><li><p>先饱和截断处理：$clamp(x,x_{min}, x_{max}) &#x3D; \min(\max(x,x_{min}), x_{max})$；</p></li><li><p>再Float-&gt;Int-&gt;Float：</p><img src="D:\Program Files\Typora\img\image-20230926154839682.png" alt="image-20230926154839682" style="zoom:50%;" /></li></ol></li><li><p>离线量化：指训练后量化(Post-Training Quantization)：</p><ol><li><p>动态离线量化(PTQ, Dynamic)：</p><p>动态离线量化仅将模型中特定算子的<strong>权重</strong>从FP32类型映射成 INT8&#x2F;16 类型，bias和激活函数 在推理过程中动态量化。但是对于不同的输入值来说，其缩放因子是<strong>动态计算</strong>的（“动态”的由来）。动态量化是几种量化方法中性能最差的。动态量化常用于非常大的模型。</p></li><li><p>静态离线量化(PTQ, Static)：</p><p>静态离线量化使用少量无标签校准数据，采用 KL 散度等方法计算量化比例因子。静态量化（Static quantization）与动态量化的区别在于其输入的缩放因子计算方法不同，静态量化的模型在使用前有“calibrate”的过程（校准缩放因子）：准备部分输入（对于图像分类模型就是准备一些图片，其他任务类似），使用静态量化后的模型进行预测，在此过程中量化模型的缩放因子会根据输入数据的分布进行调整。一旦校准完成后，权重和输入的缩放因子都固定（<strong>“静态”的由来</strong>）。静态量化的性能一般比动态量化好，常用于中等模型和大模型。因此实际中基本都是在用静态量化。</p><p>静态离线量化的目标是求取量化比例因子，主要通过对称量化、非对称量化方式来求，而找最大值或者阈值的方法又有MinMax、KLD、ADMM、EQ等方法。</p></li></ol></li></ol><img src="D:\Program Files\Typora\img\image-20230926153543814.png" alt="image-20230926153543814" style="zoom:67%;" /><ul><li>对称量化与非对称量化：对于weight权重的量化使用对称量化[-INT_MAX, INT_MAX]，对于activate激活的量化使用非对称量化[0, INT_MAX]；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在线量化：指量化感知训练(Quantization-Aware Training)，在网络模型训练阶段采用量化方案进行量化；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;量化感知训练本质上是一种伪量化的过程，它是在可识别的某些操作内嵌入伪量化节点（fake quant</summary>
      
    
    
    
    <category term="tidbits" scheme="https://stu-yue.github.io/categories/tidbits/"/>
    
    
  </entry>
  
  <entry>
    <title>Memo | Package and Device</title>
    <link href="https://stu-yue.github.io/jottings/languages/shell/memo_package_device/"/>
    <id>https://stu-yue.github.io/jottings/languages/shell/memo_package_device/</id>
    <published>2023-09-19T14:56:53.000Z</published>
    <updated>2023-11-01T03:27:05.881Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h4><ul><li>Package System</li></ul><table><thead><tr><th>Package Management System</th><th>Linux Release Version</th></tr></thead><tbody><tr><td>Debian Style (.deb)</td><td>Debian, Ubuntu</td></tr><tr><td>Red Hat Style (.rpm)</td><td>Fedora, CentOS</td></tr></tbody></table><blockquote><p>A package file is a compressed collection of files that make up a software package and may contain a large number of programs and the data files that support those programs. </p><p><strong>Metadata for the packet</strong> is included, such as a text description of the package and its contents. </p><p>Other included are <strong>pre-installation and post-installation scripts</strong> (which perform configuration tasks before and after installation)</p></blockquote><ul><li>Upper Tools and Underlying Tools:</li></ul><table><thead><tr><th>Linux Release Version</th><th>Underlying Tool (install and delete packages)</th><th>Upper Tool (search for metadata and resolve dependencies)</th></tr></thead><tbody><tr><td>Debian-Style</td><td>dpkg</td><td>apt, aptitude</td></tr><tr><td>Fedora, CentOS</td><td>rpm</td><td>yum</td></tr></tbody></table><ul><li>Search for metadata in the resource repository</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>apt update; apt search search_string</td></tr><tr><td>Red Hat</td><td>yum search search_string (e.g. yum search emacs)</td></tr></tbody></table><ul><li>Install a package via resource repository</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>apt update; apt install package_name</td></tr><tr><td>Red Hat</td><td>yum install package_name</td></tr></tbody></table><ul><li>Install a package via raw package files</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg –install &#x2F; -i package_file</td></tr><tr><td>Red Hat</td><td>rpm -i package_file (rpm -i emacs-22.1-7.fc7-i386.rpm)</td></tr></tbody></table><blockquote><p>NOTE: Due to this command is executed by rpm, not analyzing dependencies for package_file, so if a dependency is missing, rpm will report error and exit.</p></blockquote><ul><li>Uninstall a package</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>apt remove package_name  &#x2F; dpkg -r package_name</td></tr><tr><td>Red Hat</td><td>yum erase package_name</td></tr></tbody></table><ul><li>Upgrade package via resource repository</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>apt update; apt upgrade</td></tr><tr><td>Red Hat</td><td>yum update</td></tr></tbody></table><ul><li>Upgrade package via package_file</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg –install package_file</td></tr><tr><td>Red Hat</td><td>rpm -U package_file</td></tr></tbody></table><ul><li>List all package installed</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg –list &#x2F; -l</td></tr><tr><td>Red Hat</td><td>rpm -qa</td></tr></tbody></table><ul><li>Determine whether a package is installed</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg –status package_name</td></tr><tr><td>Red Hat</td><td>rpm -q package_name</td></tr></tbody></table><ul><li>Show the info for the installed package</li></ul><table><thead><tr><th>Style</th><th>Command</th></tr></thead><tbody><tr><td>Debian</td><td>apt show package_name</td></tr><tr><td>Red Hat</td><td>yum info package_name</td></tr></tbody></table><blockquote><ul><li><code>apt</code> useful arguments:<ul><li><code>-y</code> : default set yes in interactive shell;</li><li><code>-f</code>: solve the package dependencies;</li></ul></li></ul></blockquote><h4 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Package&quot;&gt;&lt;a href=&quot;#Package&quot; class=&quot;headerlink&quot; title=&quot;Package&quot;&gt;&lt;/a&gt;Package&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Package System&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;t</summary>
      
    
    
    
    <category term="languages" scheme="https://stu-yue.github.io/categories/languages/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/categories/languages/shell/"/>
    
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Summa |Networks Tidbits</title>
    <link href="https://stu-yue.github.io/jottings/networks/memo_network_tidbits/"/>
    <id>https://stu-yue.github.io/jottings/networks/memo_network_tidbits/</id>
    <published>2023-09-07T10:35:53.000Z</published>
    <updated>2023-09-08T14:19:04.994Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>Tunneling</strong>: The basic principle is to create a virtual channel between the source and the target, through which the original packets is encapsulated in the packet of another protocol, and then transmitted between the source and the target. At the target end, the receiver unwarps the encapsulated packet, reverts it to the original packet, and gives it to the target application for processing. For example, <strong>VPN (Virtual Private Network), SSH Tunneling, GRE (Generic Routing Encapsulation, like IPv6 over IPv4)</strong>.</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Tunneling&lt;/strong&gt;: The basic principle is to create a virtual channel between the source and the target, through which the</summary>
      
    
    
    
    <category term="networks" scheme="https://stu-yue.github.io/categories/networks/"/>
    
    
    <category term="networks" scheme="https://stu-yue.github.io/tags/networks/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Olds and Ends</title>
    <link href="https://stu-yue.github.io/jottings/languages/shell/memo_others/"/>
    <id>https://stu-yue.github.io/jottings/languages/shell/memo_others/</id>
    <published>2023-09-06T07:56:53.000Z</published>
    <updated>2023-09-06T07:37:09.249Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Difference between <strong>sh</strong> and <strong>bash</strong>: <strong>sh</strong> is usually symbolic link for <strong>dash</strong>; <strong>dash</strong> is a more lightweight shell, POSIX, designed to replace <strong>sh</strong> and provide faster startup and executions speeds; <strong>bash</strong> is an extended version of <strong>sh</strong>, and most scripts that conform to <strong>sh</strong> syntax should work fine in <strong>bash</strong>; <strong>In a nutshell, sh is bash, which enables the POSIX standard</strong>.</p><blockquote><p>POSIX, Portable Operating System Interface of UNIX</p><p>In accordance with the POSIX specification, “When a line of code encounters an error, it does not continue to interpret subsequent lines.” However, in bash, even if an error occurs, it will continue to execute subsequent lines.</p></blockquote></li><li><p>To view cpu information: <code>lscpu</code>, or <code>cat /proc/cpuinfo</code>;</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Difference between &lt;strong&gt;sh&lt;/strong&gt; and &lt;strong&gt;bash&lt;/strong&gt;: &lt;strong&gt;sh&lt;/strong&gt; is usually symbolic link for &lt;strong&gt;dash&lt;</summary>
      
    
    
    
    <category term="languages" scheme="https://stu-yue.github.io/categories/languages/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/categories/languages/shell/"/>
    
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Permission, Progress and Shell Environment</title>
    <link href="https://stu-yue.github.io/jottings/languages/shell/memo_permission_progress_env/"/>
    <id>https://stu-yue.github.io/jottings/languages/shell/memo_permission_progress_env/</id>
    <published>2023-08-31T14:56:53.000Z</published>
    <updated>2023-09-09T14:48:36.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h4><p>First of all, let’s take a quick look at the permissions-related commands.</p><ul><li><p><code>id</code>: To show the id number of the user.</p><ul><li><code>id username</code>:</li></ul></li><li><p><code>chmod</code>: To change the mode of files.</p><ul><li><p>symbolic examples:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u (user), g (group), o (other), a (all)</span><br><span class="line">+, -, =</span><br><span class="line">u+x   u-x   +x[=a+x]   o-rw,   go=rw   u+x,go=rw</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>umask</code>: To set default file permissions (before creating).</p><ul><li><p>an example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># umask is 0002</span><br><span class="line">Original file mode  | --- rw- rw- rw-</span><br><span class="line">Mask  | 000 000 000 010</span><br><span class="line">Result| --- rw- rw- r--</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>su</code>: To run the shell as another user. <code>su - username</code>, <code>-</code> can enter the home directory.</p></li><li><p><code>sudo</code>: To execute the command as another user.</p></li><li><p><code>chown</code>: To change the file owner.</p><ul><li><p><code>chown [owner[:group]] file...</code>, here are some examples:</p><table><thead><tr><th>Example</th><th>Explanation</th></tr></thead><tbody><tr><td>bob</td><td>change the file owner to bob</td></tr><tr><td>bob:users</td><td>change the file owner to bob, group to users</td></tr><tr><td>:admins</td><td>change the group to admins, file owner remains the same</td></tr><tr><td>bob:</td><td>change the file owner to bob, group to bob’s login group</td></tr></tbody></table></li></ul></li><li><p><code>chgrp</code>: To change the group ownership of files.</p><ul><li><code>chgrp groupname file...</code></li></ul></li><li><p><code>passwd</code>: To change the user’s password.</p><ul><li><code>passwd username</code>: set user’s password.</li></ul></li></ul><blockquote><ul><li><p>User information is stored in <code>/etc/passwd</code>, group information is stored in <code>/etc/group</code>;</p><p>use the command <code>cat /etc/passwd</code> to have a quick look.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | grep ubuntu</span><br><span class="line">        </span><br><span class="line"><span class="comment"># username:passwd:uid:gid:comment:home_dir:shell</span></span><br><span class="line"><span class="comment"># passwd (x) denotes that password is protected in /etc/passwd</span></span><br><span class="line"><span class="comment"># comment store some useful comments (like username)</span></span><br><span class="line">ubuntu:x:1000:1000:ubuntu:/home/ubuntu:/bin/bash</span><br><span class="line">        </span><br><span class="line">sudo <span class="built_in">cat</span> /etc/shadow | grep ubuntu</span><br><span class="line">        </span><br><span class="line"><span class="comment">#username:passwd(encrypted):last_modify_time:min_interval:max_interval</span></span><br><span class="line">ubuntu:$1$oQIzlBrL<span class="variable">$MErhwMGkTzqaeWkJNzpUh1</span>:19132:0:99999:7:::</span><br><span class="line">      </span><br><span class="line"><span class="built_in">cat</span> /etc/group | grep cdrom</span><br><span class="line">    </span><br><span class="line"><span class="comment"># groupname:passwd:gid:group_member</span></span><br><span class="line">cdrom:x:24:ubuntu,yue</span><br><span class="line">    </span><br><span class="line">sudo <span class="built_in">cat</span> /etc/gshadow | grep <span class="built_in">test</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># groupname:passwd:group_manager:group_member</span></span><br><span class="line"><span class="built_in">test</span>:*:yue:ubuntu</span><br></pre></td></tr></table></figure></li><li><p><strong>Permission Overview</strong>:</p></li></ul><table><thead><tr><th align="center"></th><th align="center">r</th><th align="center">w</th><th align="center">x</th></tr></thead><tbody><tr><td align="center"><strong>File</strong></td><td align="center">readable</td><td align="center">writable</td><td align="center">executable</td></tr><tr><td align="center"><strong>Directory</strong></td><td align="center">readable</td><td align="center">writable to files in the directory</td><td align="center">enterable to the directory</td></tr></tbody></table><blockquote><p>Home directory default permission: user &#x3D;rwx, go&#x3D;r-x ;</p><ul><li><code>setuid (s/S &lt;-&gt; x/-, 4000/u+s)</code> : It set valid user ID from the running user’s ID to the file owner’s ID;</li><li><code>setgid (g/G &lt;-&gt; x/-, 2000/g+s)</code>: Run not with the permissions of the group to which the user who started it belongs, but with the group that owns the file. In other words, <strong>the process gid is the same as the file gid</strong>.</li><li><code>sticky (t/T &lt;-&gt; x/-, 1000/o+t)</code>: It has no effect on files, but when it is used on a directory, all files in the directory can only be deleted or moved by their owner.</li></ul></blockquote><ul><li><strong>File Type</strong>:</li></ul><table><thead><tr><th align="center">Tag</th><th align="center">Type</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">a normal file</td></tr><tr><td align="center">d</td><td align="center">a directory</td></tr><tr><td align="center">l</td><td align="center">a symbolic link (real file property is the file property that the symbolic link points to)</td></tr><tr><td align="center">c</td><td align="center">a character device file (process bytes stream, like terminal)</td></tr><tr><td align="center">b</td><td align="center">a block device file (process blocks, like hard-disk or CD-ROM)</td></tr></tbody></table></blockquote><h4 id="User-and-Group"><a href="#User-and-Group" class="headerlink" title="User and Group"></a>User and Group</h4><p>Because the permission is too large, you can even delete system files and crash the system. Therefore, you are not recommended to directly use <strong>root</strong> account.</p><p>On Linux systems, <code>sudo</code> is used as the default <strong>root</strong> identity for standard users.</p><p>Next, we have some commands for managing users and groups.</p><ul><li><p><code>groupadd</code>: create a new work group, whose info is added to <code>/etc/group</code>, <code>/etc/gshadow</code> and so on.</p><ul><li><code>[-g gid]</code> (specify the id of new group), <code>-r</code> (create system working groups)</li></ul></li><li><p><code>groupdel</code>: delete a group</p></li><li><p><code>gpasswd [options] groupname</code>: management tool the <code>/etc/group</code> and <code>/etc/gshadow</code></p><ul><li><code>-a/d username</code> (add&#x2F;delete user to group)</li><li><code>-A</code> (specify the manager)</li><li><code>-r/R</code> (cancel the password for the group, then only group member can <code>newgrp</code> to access the group)</li><li><code>-M user1,user2...</code>  add users to group</li></ul></li><li><p><code>groupmod</code>: change the group information</p><ul><li><code>-g gid</code> (change group id)</li><li><code>-n new_name old_name</code> (change group name)</li></ul></li><li><p><code>newgrp groupname</code>: It’s using the same account another group name, to log into the system again.</p></li><li><p><code>useradd</code>: create a new user.</p><ul><li><p><code>-m/M</code> (automatically &#x2F; <strong>not</strong> create a user <strong>home directory</strong>), </p></li><li><p><code>-g</code> (specify the login group), </p></li><li><p><code>-G grp1,grp2...</code> (specify the supplementary groups)</p></li><li><p><code>-d</code> (specify the starting directory for the user to log in to), </p></li><li><p><code>-r</code> (create a system account)</p></li><li><p><code>-s</code> (specify the login shell)</p></li><li><p><code>-n</code> (cancel creating a group with the user name)</p></li><li><p><code>-p</code> (specify the password, or later run the command <code>passwd</code> to set)</p><p><code>useradd -m -g root username</code>, <code>useradd -d /home/test username</code></p></li></ul></li><li><p><code>userdel</code>: <code>-r</code> (recursively delete)</p></li></ul><blockquote><p>Initial <strong>Login Group</strong>, is a group that a user owns immediately upon login. It’s usually specified with <code>-g</code> when creating a user. The GID in the user info (<code>/etc/passwd</code>) is <strong>login group</strong>. A user’s additional group is to assign additional permission to the specified user. (There can be only one <strong>login group</strong> and multiple <strong>supplementary group</strong>)</p></blockquote><ul><li><code>usermod</code>: modify the settings of the user account.<ul><li><code>-d</code>: set login directory of the user account</li><li><code>-e</code>: set validity period …</li><li><code>-g</code>: set the login group …</li><li><code>-G</code>: set the supplementary group …</li><li><code>-s</code>: set the shell used after login …</li><li><code>-l new_name old_name</code>: set the new username …</li><li><code>-L/U</code>: lock&#x2F;unlock the account …</li><li><code>-p</code>: set the new password …</li></ul></li></ul><h4 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h4><p>When the system starts, the kernel initializes some of its own activities as <strong>Init Process</strong> (PID 1). In turn, a series of shell scripts called <strong>Init Scripts</strong> (located in <code>/etc</code>) are run, which can start all system services. Many of these system services are implemented in the form of <strong>daemons</strong>, which run only in the background without any user interface (inaccessible). Here are some of the command-line tools available:</p><ul><li><p><code>ps</code>: To view the snapshot of process status;</p><ul><li><p>common parameter <code>aux</code> (show all processes)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-16-17-ubuntu:/etc$ ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># TTY: ? denotes terminal running locally, Pts/n denotes terminal running remotely</span></span><br><span class="line"><span class="comment"># VSZ: virtual memory size</span></span><br><span class="line"><span class="comment"># RSS: physical memory size occupied by process</span></span><br><span class="line"><span class="comment"># STAT: R(running), S(sleeping), D(uninterruptible sleeping), T(terminal), Z(zombie) &lt;(high priority) N(low priority)</span></span><br></pre></td></tr></table></figure><blockquote><p>Ctrl-C: send a SIGIN</p><p>Ctrl-D: send a EOF</p><p>Ctrl-Z: send a SIGSTP, pause ongoing process on the terminal so as to be resumed when necessary.</p></blockquote></li></ul></li><li><p><code>top</code>: To displays a continuously updated list of system process in order of process activity (default, refresh per 3s);</p></li><li><p><code>jobs</code>: </p></li><li><p><code>bg</code>: </p></li><li><p><code>fg</code>: </p></li><li><p><code>kill</code>: To send signals to programs (<code>kill [-signal] PID...</code>);</p><ul><li><table><thead><tr><th>NO.</th><th>NAME</th><th>EXPLANATION</th></tr></thead><tbody><tr><td>1</td><td>HUP</td><td>Hang up, this signal is used to tell the program that the control terminal has “hung up.” You can show what this signal does by closing a terminal session. Foreground programs running on the current terminal will receive this signal and terminate. Many daemons also use this signal to re-initialize.</td></tr><tr><td>2</td><td>INT</td><td>like Ctrl-c</td></tr><tr><td>9</td><td>KILL</td><td>The KILL signal is never sent to the target program. Instead, the kernel immediately terminates the process. When a process is terminated in this way, it has no opportunity to do any “cleaning” or saving work.</td></tr><tr><td>15</td><td>TERM</td><td>Terminal, this is default signal sent by KILL</td></tr><tr><td>18</td><td>CONT</td><td>Continue, after getting a stop signal, program will be resumed by CONT</td></tr><tr><td>19</td><td>STOP</td><td>like KILL, STOP is not sent to the target process, so it cannot be ignored</td></tr></tbody></table><p>其他常用信号：</p><table><thead><tr><th>NO.</th><th>NAME</th><th>EXPLANATION</th></tr></thead><tbody><tr><td>3</td><td>QUIT</td><td></td></tr><tr><td>11</td><td>SEGV</td><td>If a program uses memory illegally, this signal will be sent</td></tr><tr><td>20</td><td>TSTP</td><td>Ctrl-z will trigger this signal to cause terminal stop, unlike STOP, it can be ignored</td></tr></tbody></table></li></ul></li><li><p><code>killall</code>: To send signals to multiple processes that match a particular program or username (<code>killall [-u user] [-signal] name...</code>);</p></li><li><p><code>shutdown</code>: To shutdown the machine or reboot;</p></li></ul><h4 id="Shell-Environment"><a href="#Shell-Environment" class="headerlink" title="Shell Environment"></a>Shell Environment</h4><ul><li><p><code>printenv</code>: </p></li><li><p><code>set</code>: To display existing shell variables in the system and set new variable values for shell variables.</p></li><li><p>When user log in to the system, the <strong>bash</strong> program starts and reads a series of configuration scripts (startup files that define a default environment for all users), then it reads the startup files in the home directory that define the user’s personal shell environment.</p><p>The exact startup order depends on the type of shell session you want to run. There are two types, one is login shell session (need username and password), the other is non-login shell session (start under the GUI).</p><p><strong>Login shell startup order</strong>:</p><table><thead><tr><th>File</th><th>Usage</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;profile</td><td>global conf script applying to all users</td></tr><tr><td>~&#x2F;.bash_profile</td><td>user’s personal startup file, used to extend or override settings in global conf script</td></tr><tr><td>~&#x2F;.bash_login</td><td>if ~&#x2F;.bash_profile is not found, bash will try to read this script</td></tr></tbody></table><p><strong>Non-login shell startup order</strong>: </p><table><thead><tr><th>File</th><th>Usage</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;bash.bashrc</td><td>global conf script applying to all users</td></tr><tr><td>~&#x2F;.bashrc</td><td>user’s personal startup file, used to extend or override settings in global conf script</td></tr></tbody></table><p>In addition to reading the startup files above, <strong>non-login shell also inherit the environment settings of their parent process, usually a login shell</strong>. </p><p>In general users’ points, <strong>the file ~&#x2F;.bashrc is probably the most important startup file</strong> because it’s almost always read. <strong>Non-login shells read it by default, and most startup files for login shells are written in such a way that they can read ~&#x2F;.bashrc</strong> . The below is a typical .bash_profile file (From CentOS 4):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"><span class="comment"># Get the aliaes and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">. ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure></li><li><p><code>export</code>: export environment variables;</p></li><li><p><code>alias</code>: create alias for command;</p></li></ul><h4 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h4><p><a href="https://blog.csdn.net/coobeedongzhou/article/details/24492581">ref1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Permission&quot;&gt;&lt;a href=&quot;#Permission&quot; class=&quot;headerlink&quot; title=&quot;Permission&quot;&gt;&lt;/a&gt;Permission&lt;/h4&gt;&lt;p&gt;First of all, let’s take a quick look </summary>
      
    
    
    
    <category term="languages" scheme="https://stu-yue.github.io/categories/languages/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/categories/languages/shell/"/>
    
    
    <category term="linux" scheme="https://stu-yue.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://stu-yue.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Memo | Parameter Estimation</title>
    <link href="https://stu-yue.github.io/jottings/mathematics/memo_mle_mae_bayes/"/>
    <id>https://stu-yue.github.io/jottings/mathematics/memo_mle_mae_bayes/</id>
    <published>2023-08-30T05:56:53.000Z</published>
    <updated>2023-08-30T09:21:54.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Through this note, I hope to deepen my understanding of probability distribution and inference.</p></blockquote><h4 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h4><blockquote><ul><li><strong>Probability:</strong> to predict results obtained in the next observation when parameters are known;</li><li><strong>Statistic&#x2F;Likelihood:</strong> to estimate parameters about properties when the result of observations are known;</li><li><strong>Parametric Method:</strong>  assume that  the learned distribution has a specific functional form (like Gaussian distribution or exponential p.d.f), we only estimate the parameters in these functions.</li><li><strong>Nonparametric Method</strong>: use the training samples to estimate the density of any point in the domain.<ul><li>Nonparametric methods also have parameters, we just don’t assume any specific functional form for distribution;</li><li>Actually, nonparametric methods treat all training samples as parameters;</li><li>example: kernel density estimation;</li></ul></li></ul></blockquote><ol><li>Under the joint distribution $p_{X,Y}(X,Y)$:<ul><li>When the effect of $Y$ is removed from the joint distribution $p_{X,Y}(X,Y)$,  <em>marginal distribution</em> $p_X(X)$ is called <strong>marginal likelihood</strong>;</li><li>When $X$ has not yet been observed,  <em>marginal distribution</em> $p_Y(Y)$ is called <strong>prior distribution</strong>;</li></ul></li><li><strong>Posterior Distribution</strong>:  $p(\theta|\mathcal{D}) &#x3D; \frac{p(\mathcal{D},\theta)}{p(\mathcal{D})}$, concentrating <em>Population Info, Sample Info and Prior Info</em>;<ul><li>$p(\mathcal{D})$ is marginal likelihood;</li><li>$\text{Posterior} &#x3D; \frac{\text{Likelihood}\times \text{Prior}}{\text{Marginal Likelihood}}$, in terms of $p(Y|X) &#x3D; \frac{1}{Z}p(X|Y)p(Y)$, $Z&#x3D;p(X)&gt;0$ is a normalized constant such that $p(Y|X)$ is a valid probability distribution.</li></ul></li><li>The Views<ul><li>Frequentist: <ul><li>Data are repeatable random sample - there is a frequency;</li><li>Underlying parameters remain constant during this repeatable process;</li><li><em>Parameters are <strong>fixed value</strong></em>;</li><li><em>statistical inference: Population Info + Sample Info</em></li><li>MLE, MAP;</li></ul></li><li>Bayesian: <ul><li>Data are observed from the realized sample;</li><li><em>Parameters are unknown <strong>(random variable)</strong> and described probabilistically <strong>(prior distribution)</strong></em>;</li><li><em>statistical inference: Population Info + Sample Info + <strong>Prior Info (Main Diff)</strong></em>;</li><li>Bayesian Estimation;</li></ul></li></ul></li></ol><blockquote><p><strong>Notations</strong></p><ul><li>Training Data: $\mathcal{D} &#x3D; { (\mathbf{x_1}, y_1),\cdots,(\mathbf{x}_n, y_n) }$;</li><li>Model Parameter: $\theta$;</li><li>New Data: $x^*$;</li></ul></blockquote><h4 id="Maximum-Likelihood-Estimation"><a href="#Maximum-Likelihood-Estimation" class="headerlink" title="Maximum Likelihood Estimation"></a>Maximum Likelihood Estimation</h4><ul><li><p>Objective is<br>$$<br>\theta_{MLE}^* &#x3D; \arg\max_\theta p(\mathcal{D}|\theta)<br>$$</p><ul><li>$p(\mathcal{D}|\theta)$ is likelihood, not conditional probability;</li></ul><p>Usually, we define<br>$$<br>\mathscr{l}(\theta) &#x3D; p(\mathcal{D}|\theta) \<br>\mathscr{ll}(\theta) &#x3D; \ln \mathscr{l}(\theta)<br>$$<br>So, objective is equivalent to<br>$$<br>\theta_{MLE}^* &#x3D; \arg\max_\theta \mathscr{ll}(\theta)<br>$$<br>That is, we seek those values for the parameters in $\theta$ which maximize $p(\mathcal{D}|\theta)$. The MLE solution is usually obtained by setting<br>$$<br>\frac{\partial \mathscr{ll}(\theta)}{\partial\theta} &#x3D; 0<br>$$</p></li><li><p><font color=red>However, the model…</font></p><ul><li>Does not incorporate prior belief;</li><li>Easy to overfit the data;</li></ul></li></ul><h4 id="Maximum-A-Posteri-Estimation"><a href="#Maximum-A-Posteri-Estimation" class="headerlink" title="Maximum A Posteri Estimation"></a>Maximum A Posteri Estimation</h4><ul><li><p>Objective is<br>$$<br>\theta^*_{MAP} &#x3D; \arg\max_\theta p(\theta|\mathcal{D})<br>$$<br>Since we have Bayes rule:<br>$$<br>p(\theta | \mathcal{D}) &#x3D; \frac{p(\mathcal{D})p(\theta)}{p(\mathcal{D})}<br>$$<br>Our objective is equivalent to<br>$$<br>\theta^*_{MAP} &#x3D; \arg\max_\theta p(\mathcal{D}|\theta)p(\theta)<br>$$<br>Further, by taking the log<br>$$<br>\theta^*_{MAP} &#x3D; \arg\max_\theta {\ln p(\mathcal{D}|\theta) + lnp(\theta) } \<br>\theta^*_{MAP} &#x3D; \arg\max_\theta { \mathscr{ll}(\theta) + \ln p(\theta) }<br>$$<br>Thus, our final goal is to find<br>$$<br>\theta^*_{MAP} &#x3D; \arg\max_\theta { \mathscr{ll}(\theta) + \ln p(\theta) }<br>$$<br>The difference between MAP and MLE is the “extra” term - $p(\theta)$. The term is:</p><ul><li>our prior (belief)</li><li>also can be seen as penalty (regularization) - to reduce the overfitting.</li></ul></li></ul><blockquote><p> For $p(\theta|\mathcal{D})$, in terms of <strong>point estimation</strong> for $\theta$,</p><ul><li>using the <strong>maximum value</strong> is called <strong>Maximum A Posterior Estimation</strong>;</li><li>using the <strong>median value</strong> is called <strong>Posteriror Median Estimation</strong>;</li><li>using the <strong>expectation value</strong> is called <strong>Posterior Expectation Estimation</strong>;</li></ul></blockquote><h4 id="Bayesian-Estimation"><a href="#Bayesian-Estimation" class="headerlink" title="Bayesian Estimation"></a>Bayesian Estimation</h4><blockquote><ul><li>$p(\theta|\mathcal{D})$ (it’s the result of adjustments to prior $p(\theta)$ by population and sample);</li><li><strong>Equal Ignorance</strong>: If there’s no information about the prior distribution, assume $\theta \sim U(0,1)$ ;</li></ul></blockquote><ul><li><p>Learning:  Computing the posterior $p(\theta|\mathcal{D})$ ;</p></li><li><p>Prediction:  $p(\hat y | x^*,\mathcal{D}) &#x3D; \int_\theta p(\hat y | x^*,\theta)p(\theta|\mathcal{D})d\theta$ ;</p></li><li><p><font color=red>Both MLE and MAP return only single and specific values for the paramter $\theta$; </font></p><p><font color=blue>Bayesian estimation, by contrast, calculates fully the posterior distribution $p(\theta|\mathcal{D})$, </font> and making prediction by considering all possible $\theta$.</p><p>Thus, for Bayesian methods:</p><ul><li>The prediction is optimal</li><li>Avoid the overfitting</li></ul></li><li><p><font color=blue>Bayesian is powerful, but…</font></p><p>We need to compute posterior distribution $p(\theta|\mathcal{D})$, and<br>$$<br>p(\theta|\mathcal{D}) &#x3D; \frac{p(\mathcal{D}|\theta)p(\theta)}{\int p(\mathcal{D},\theta)d\theta}<br>$$<br>In practice, evaluating this posterior is usually intractable due to the <font color=red>complex integrals</font>…</p></li></ul><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://yuanxiaosc.github.io/2018/06/20/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1%E3%80%81%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E3%80%81%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/">Mainly Ref</a></p><p><a href="https://blog.csdn.net/u011508640/article/details/72815981">Ref2</a></p><p><a href="https://www.zhangzhenhu.com/glm/source/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1/content.html">Ref3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Through this note, I hope to deepen my understanding of probability distribution and inference.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Pr</summary>
      
    
    
    
    <category term="mathematics" scheme="https://stu-yue.github.io/categories/mathematics/"/>
    
    
    <category term="math" scheme="https://stu-yue.github.io/tags/math/"/>
    
  </entry>
  
</feed>
